{
    "optim": "The SCIP Optimization Suite 9.0\nSuresh Bolusani\n· Mathieu Besan¸con\n· Ksenia Bestuzheva\nAntonia Chmiela\n· Jo˜ao Dion´ısio\n· Tim Donkiewicz\nJasper van Doornmalen\n· Leon Eifler\n· Mohammed Ghannam\nAmbros Gleixner\n· Christoph Graczyk\n· Katrin Halbig\nIvo Hedtke\n· Alexander Hoen\n· Christopher Hojny\nRolf van der Hulst\n· Dominik Kamp\n· Thorsten Koch\nKevin Kofler · Jurgen Lentz\n· Julian Manns · Gioni Mexi\nErik M¨uhmer\n· Marc E. Pfetsch\n· Franziska Schl¨osser\nFelipe Serrano\n· Yuji Shinano\n· Mark Turner\nStefan Vigerske\n· Dieter Weninger\n· Liding Xu\n∗\n26 February 2024\nAbstract\nThe SCIP Optimization Suite provides a collection of software packages for\nmathematical optimization, centered around the constraint integer programming (CIP)\nframework SCIP. This report discusses the enhancements and extensions included in\nSCIP Optimization Suite 9.0. The updates in SCIP 9.0 include improved symmetry\nhandling, additions and improvements of nonlinear handlers and primal heuristics, a\nnew cut generator and two new cut selection schemes, a new branching rule, a new LP\ninterface, and several bugfixes. SCIP Optimization Suite 9.0 also features new Rust and\nC++ interfaces for SCIP, new Python interface for SoPlex, along with enhancements\nto existing interfaces. SCIP Optimization Suite 9.0 also includes new and improved\nfeatures in the LP solver SoPlex, the presolving library PaPILO, the parallel framework\nUG, the decomposition framework GCG, and the SCIP extension SCIP-SDP. These\nadditions and enhancements have resulted in an overall performance improvement of\nSCIP in terms of solving time, number of nodes in the branch-and-bound tree, as well\nas the reliability of the solver.\nKeywords\nConstraint integer programming · linear programming · mixed-integer linear\nprogramming · mixed-integer nonlinear programming · optimization solver · branch-and-\ncut · branch-and-price · column generation · parallelization · mixed-integer semidefinite\nprogramming\nMathematics Subject Classification\n90C05 · 90C10 · 90C11 · 90C30 · 90C90 ·\n65Y05\n∗Extended author information is available at the end of the paper. The work for this article has been\npartly conducted within the Research Campus MODAL funded by the German Federal Ministry\nof Education and Research (BMBF grant number 05M14ZAM) and has received funding from the\nEuropean Union’s Horizon 2020 research and innovation programme under grant agreement No 773897.\nIt has also been partly supported by the German Research Foundation (DFG) within the Collaborative\nResearch Center 805, Project A4, and the EXPRESS project of the priority program CoSIP (DFG-SPP\n1798), the German Research Foundation (DFG) within the project HPO-NAVI (project number\n391087700).\n1\narXiv:2402.17702v1  [math.OC]  27 Feb 2024\n1 Introduction\nThe SCIP Optimization Suite comprises a set of complementary software packages\ndesigned to model and solve a large variety of mathematical optimization problems:\n− the constraint integer programming solver SCIP [3], a solver for mixed-integer linear\nand nonlinear programs as well as a flexible framework for branch-cut-and-price,\n− the simplex-based linear programming solver SoPlex [99],\n− the modeling language Zimpl [60],\n− the presolving library PaPILO for linear and mixed-integer linear programs,\n− the automatic decomposition solver GCG [31], and\n− the UG framework for parallelization of branch-and-bound solvers [84].\nAll six tools are freely available as open-source software packages, either using the\nApache 2.0 or the GNU Lesser General Public License. There also exist two notable\ncontinuously developed extensions to the SCIP Optimization Suite: the award-winning\nSteiner tree solver SCIP-Jack [32] and the mixed-integer semidefinite programming\nsolver SCIP-SDP [30].\nThis report describes the improvements and new features\ncontained in version 9.0 of the SCIP Optimization Suite.\nBackground\nSCIP is designed as a solver for constraint integer programs (CIPs), a\ngeneralization of mixed-integer linear and nonlinear programs (MILPs and MINLPs).\nCIPs are finite-dimensional optimization problems with arbitrary constraints and a\nlinear objective function that satisfy the following property: if all integer variables\nare fixed, the remaining subproblem must form a linear or nonlinear program (LP or\nNLP). To solve CIPs, SCIP constructs relaxations—typically linear relaxations, but also\nnonlinear relaxations are possible, or relaxations based on semidefinite programming\nfor SCIP-SDP. If the relaxation solution is not feasible for the current subproblem,\nan enforcement procedure is called that takes measures to resolve the infeasibility, for\nexample by branching or by separating cutting planes.\nThe most important subclass of CIPs that are solvable with SCIP are mixed-integer\nprograms (MIPs) which can be purely linear (MILPs) or contain nonlinearities (MINLPs).\nMILPs are optimization problems of the form\nmin\nc⊤x\ns.t.\nAx ≥ b,\nℓi ≤ xi ≤ ui\nfor all i ∈ N,\nxi ∈ Z\nfor all i ∈ I,\n(1)\ndefined by c ∈ Rn, A ∈ Rm×n, b ∈ Rm, ℓ, u ∈ Rn, and the index set of integer variables\nI ⊆ N := {1, . . . , n}. The usage of R := R ∪ {−∞, ∞} allows for variables that are free\nor bounded only in one direction (we assume that variables are not fixed to ±∞). In\ncontrast, MINLPs are optimization problems of the form\nmin\nf(x)\ns.t.\ngk(x) ≤ 0\nfor all k ∈ M,\nℓi ≤ xi ≤ ui\nfor all i ∈ N,\nxi ∈ Z\nfor all i ∈ I,\n(2)\nwhere the functions f : Rn → R and gk : Rn → R, k ∈ M := {1, . . . , m}, are possibly\nnonconvex. Within SCIP, we assume that f is linear and that gk are specified explicitly\nin algebraic form using a known set of base expressions.\n2\nDue to its design as a solver for CIPs, SCIP can be extended by plugins for more\ngeneral or problem-specific classes of optimization problems. The core of SCIP is formed\nby a central branch-cut-and-price algorithm that utilizes an LP as the default relaxation\nwhich can be solved by a number of different LP solvers, controlled through a uniform LP\ninterface. To be able to handle any type of constraint, a constraint handler interface is\nprovided, which allows for the integration of new constraint types, and provides support\nfor many different well-known types of constraints out of the box. Further, advanced\nsolving methods like primal heuristics, branching rules, and cutting plane separators can\nalso be integrated as plugins with a pre-defined interface. SCIP comes with many such\nplugins needed to achieve a good MILP and MINLP performance. In addition to plugins\nsupplied as part of the SCIP distribution, new plugins can be created by users. The\ndesign approach and solving process is described in detail by Achterberg [2].\nAlthough it is a standalone solver, SCIP interacts closely with the other components\nof the SCIP Optimization Suite. Zimpl is integrated into SCIP as a reader plugin,\nmaking it possible to read Zimpl problem instances directly by SCIP. PaPILO is\nintegrated into SCIP as an additional presolver plugin. The LPs that need to be solved\nas relaxations in the branch-and-bound process are by default solved with SoPlex.\nInterfaces to most actively developed external LP solvers exist, and new interfaces can\nbe added by users. GCG extends SCIP to automatically detect problem structure and\ngenerically apply decomposition algorithms based on the Dantzig-Wolfe or the Benders’\ndecomposition schemes. Finally, the default instantiations of the UG framework use\nSCIP as a base solver in order to perform branch-and-bound in parallel computing\nenvironments with shared or distributed memory architectures.\nNew Developments and Structure of the Report\nThis report is structured into three\nmain parts. First, the changes and progress made in the solving process of SCIP are\nexplained and the resulting performance improvements on MILP and MINLP instances\nare analyzed, both in terms of performance and robustness. A performance comparison\nof SCIP 9.0 against SCIP 8.0 is carried out in Section 2.\nSecond, improvements to the core of SCIP are presented in Section 3, which include\n− improved symmetry handling on non-binary variables, symmetry handling for custom\nconstraints, and signed permutation symmetries,\n− symmetry preprocessing using the new interfaces to nauty and sassy,\n− a new constraint handler for signomial inequalities as well as cut-strengthening for\nquadratic expressions,\n− a new indicator diving heuristic, extensions to the existing dynamic partition search\nheuristic, as well as a new online scheduling feature for primal heuristics,\n− a new Lagromory separator, as well as improvements in cut selection,\n− a new branching criterion called GMI branching that is incorporated into the existing\nscoring function and acts as a tie-breaker for the existing branching rules,\n− a new interface to the HiGHS LP solver [54], and\n− certain technical improvements.\nThird, improvements to the other components of the SCIP Optimization Suite and\nextensions to the interfaces are presented. Improvements to the default LP solver SoPlex\nand presolver PaPILO are explained in Sections 4 and 5, respectively. Extensions to the\ninterfaces of SCIP are presented in Section 6. Besides improvements and extensions to\nexisting interfaces, this section includes two new interfaces for SCIP: (1) russcip [80],\na new Rust interface, and (2) SCIP++ [83], a new C++ interface, as well as a new\nPython interface for SoPlex called PySoPlex [78].\nImprovements to distributed\ncomputing with UG and to Dantzig-Wolfe decompositions with GCG are presented in\nSections 7, and 8, respectively; and finally updates to the SCIP extension SCIP-SDP\n3\nfor semidefinite problems are presented in Section 9. Not included in this release, but\navailable as a beta version, is ExactSCIP [27], a new extension of SCIP that allows for\nthe exact solution of MILPs with rational input data without roundoff errors and zero\nnumerical tolerances.\n2 Overall Performance Improvements for MILP and MINLP\nIn this section, we present computational experiments conducted by running SCIP\nwithout parameter tuning or algorithmic variations to assess the performance changes\nsince the 8.0.0 release. We detail below the methodology and results of these experiments.\nThe indicators of interest to compare the two versions of SCIP on a given subset of\ninstances are the number of solved instances, the shifted geometric mean of the number\nof branch-and-bound nodes, and the shifted geometric mean of the solving time. The\nshifted geometric mean of values t1, . . . , tn is\n n\nY\ni=1\n(ti + s)\n!1/n\n− s.\nThe shift s is set to 100 nodes and 1 second, respectively.\n2.1 Experimental Setup\nAs baseline we use SCIP 8.0.0, with SoPlex 6.0.0 as the underlying LP solver, and\nPaPILO 2.0.0 for enhanced presolving. We compare it with SCIP 9.0.0 with SoPlex\n7.0.0 and PaPILO 2.2.0. Both SCIP versions were compiled using GCG 10.2.1, use\nIpopt 3.14.14 as NLP subsolver built with HSL MA27 as linear system solver, Intel\nMKL as linear algebra package, CppAD 20180000.0 as algorithmic differentiation library,\nand bliss 0.77 for graph automorphisms to detect symmetry in MIPs. SCIP 9.0.0\nadditionally uses sassy 1.1 as a preprocessor for bliss. The time limit was set to 7200\nseconds in all cases. Furthermore, for MINLP, a relative gap limit of 10−4 and an\nabsolute gap limit of 10−6 were set.\nThe MILP instances were selected from MIPLIB 2017 [40], including all instances\npreviously solved by previous SCIP versions with at least one of five random seeds or\nnewly solved by SCIP 9.0.0 with at least one of five random seeds; this amounted to\n158 instances. The MINLP instances were selected in a similar way from the MINLPLib1\nfor a total of 179 instances.\nAll performance runs were carried out on identical machines with Intel Xeon Gold\n5122 @ 3.60GHz and 96GB RAM. A single run was carried out on each machine in a\nsingle-threaded mode. Each instance was solved with SCIP using five different seeds for\nrandom number generators. This results in a testset of 790 MILPs and 810 MINLPs.\nInstances for which the solver reported numerically inconsistent results are excluded from\nthe results below.\n2.2 MILP Performance\nTable 1 presents a comparison between SCIP 9.0 and SCIP 8.0 regarding their MILP\nperformance. SCIP 9.0 improves the solving capabilities for MILP by solving 19 more\ninstances than SCIP 8.0. In terms of the shifted geometric mean of the running time,\nboth versions perform almost equally across all instances, with SCIP 9.0 being 2% faster\n1https://www.minlplib.org\n4\non affected instances. On the subset of harder instances in the [1000,7200] bracket,\ni.e., instances that take at least 1000 seconds to be solved with at least one setting,\nthe speedup is larger and amounts to 6%. To compare average tree size across the two\nversions, we restrict to the both-solved subset since the number of nodes for instances that\ntime out is not easy to interpret. In the both-solved subset, SCIP 9.0 significantly reduces\nthe average tree size by 17%. Finally, it’s worth noting that SCIP 9.0 incorporates\na large number of bugfixes. While these bugfixes have introduced a slowdown, they\ncontribute significantly to the overall reliability of the solver.\nTable 1: Performance comparison of SCIP 9.0 and SCIP 8.0 for MILP instances\nSCIP 9.0.0+SoPlex 7.0.0\nSCIP 8.0.0+SoPlex 6.0.0\nrelative\nSubset\ninstances\nsolved\ntime\nnodes\nsolved\ntime\nnodes\ntime\nnodes\nall\n785\n637\n433.9\n4307\n618\n439.0\n5236\n1.01\n1.22\naffected\n647\n610\n297.1\n3874\n591\n301.8\n4763\n1.02\n1.23\n[0,tilim]\n674\n637\n272.9\n3332\n618\n276.7\n4065\n1.01\n1.22\n[1,tilim]\n669\n632\n283.8\n3423\n613\n287.7\n4182\n1.01\n1.22\n[10,tilim]\n617\n580\n399.8\n4463\n561\n404.9\n5567\n1.01\n1.25\n[100,tilim]\n460\n423\n986.9\n11282\n404\n985.4\n14244\n1.00\n1.26\n[1000,tilim]\n278\n241\n2240.0\n30971\n222\n2383.3\n41101\n1.06\n1.33\ndiff-timeouts\n93\n56\n3899.0\n100922\n37\n4592.9\n160892\n1.18\n1.59\nboth-solved\n581\n581\n178.1\n1897\n581\n176.2\n2220\n0.99\n1.17\n2.3 MINLP Performance\nTable 2 summarizes the results for the performance of SCIP 9.0 as compared to SCIP\n8.0 for the MINLP instances. Besides increasing the number of solved instances by 5, the\nchanges introduced in SCIP 9.0 improve the performance of SCIP in both the overall\nsolving time as well as the number of nodes needed. On the whole testset, SCIP 9.0\nimproves the performance by about 4% in time and by 13% in nodes, both in shifted\ngeometric means. This improvement increases with the difficulty of the instances: When\nlooking at the most difficult testset [1000, 7200], SCIP 9.0 outperforms SCIP 8.0 by\n20% and 46% in the solving time and nodes in shifted geometric means, respectively.\nFurthermore, the improvement in solving time is mainly observed on nonconvex instances.\nIn particular, SCIP 9.0 is 8% faster than SCIP 8.0 on nonconvex instances whereas both\nversions perform almost equally when only convex instances are considered.\n3 SCIP\n3.1 Symmetry Handling\nSymmetries of an MILP or MINLP are maps that transform feasible solutions into\nfeasible solutions with the same objective value. When not handled appropriately, such\nsymmetries deteriorate the performance of (spatial) branch-and-bound algorithms since\nsymmetric solutions are found and symmetric subproblems are explored repeatedly\nwithout providing additional information to the solver. The previous versions of SCIP\nhave already contained many state-of-the-art algorithms to handle symmetries of binary\nvariables and some basic cutting planes to also handle symmetries of integer or continuous\nvariables.\nSCIP 9.0 substantially extends the ability to handle symmetries in three directions.\nFirst, more sophisticated techniques are available to handle symmetries of non-binary\nvariables. Second, the mechanism to detect symmetries has been completely restructured.\nWhile previous versions of SCIP could only detect symmetries of the available classes\n5\nTable 2: Performance comparison of SCIP 9.0 and SCIP 8.0 for MINLP instances\nSCIP 8.0.0+SoPlex 6.0.0\nSCIP 9.0.0+SoPlex 7.0.0\nrelative\nSubset\ninstances\nsolved\ntime\nnodes\nsolved\ntime\nnodes\ntime\nnodes\nall\n839\n810\n32.6\n2800\n815\n31.2\n2489\n1.04\n1.13\naffected\n783\n770\n32.4\n2949\n775\n31.4\n2608\n1.03\n1.13\n[0,7200]\n823\n810\n29.3\n2613\n815\n28.0\n2323\n1.04\n1.12\n[1,7200]\n767\n754\n36.6\n3288\n759\n34.9\n2907\n1.05\n1.13\n[10,7200]\n529\n516\n97.0\n6333\n521\n90.2\n5498\n1.08\n1.15\n[100,7200]\n248\n235\n489.1\n29290\n240\n414.0\n21767\n1.18\n1.35\n[1000,7200]\n96\n83\n2020.8\n110115\n88\n1682.8\n75556\n1.20\n1.46\ndiff-timeouts\n21\n8\n3492.6\n72059\n13\n1691.3\n21896\n2.07\n3.29\nboth-solved\n802\n802\n25.7\n2389\n802\n25.1\n2187\n1.03\n1.09\nconvex\n168\n163\n31.4\n3601\n165\n31.0\n3177\n1.01\n1.13\nnonconvex\n571\n547\n38.0\n2783\n550\n35.2\n2443\n1.08\n1.14\nof constraints, SCIP 9.0 can also detect symmetries of custom constraints added by\nusers. Moreover, SCIP 9.0 can also detect so-called signed permutation symmetries,\nwhereas previous versions could only detect permutation symmetries. Finally, to detect\nsymmetries, SCIP makes use of external software for detecting graph automorphisms.\nIn the latest version, new interfaces to nauty [74] as well as the preprocessor sassy [6]\nhave been added.\n3.1.1 Symmetry Handling Methods\nFor the ease of exposition, consider an MILP min {c⊤x : Ax ≥ b, x ∈ Zp × Rn−p},\nwhere A ∈ Rm×n, b ∈ Rm, and c ∈ Rn. Symmetries in MILP are commonly permuting\nvariables, i.e., a permutation γ of [n] acts on x ∈ Rn as γ(x) = (xγ−1(1), . . . , xγ−1(n)).\nPermutation γ is called a formulation symmetry of the MILP if there is a permutation π\nof [m] such that γ(c) = c, π(b) = b, Aπ−1(i),γ−1(j) = Ai,j for all (i, j) ∈ [m] × [n],\nand γ(i) ∈ [p] for all i ∈ [p]. Formulation symmetries can be detected by constructing a\ncolored graph whose color-preserving automorphisms correspond to symmetries of the\nMILP, see [81] and Section 3.1.2 for more details. Moreover, the definition of formulation\nsymmetries can be extended to MINLPs by keeping the representation of nonlinear\nconstraints via expression trees invariant [63].\nIn previous versions of SCIP, three main classes of symmetry handling methods have\nbeen available:\n1. Propagation and separation algorithms for the symmetry handling constraints orbi-\nsack [50, 51, 56, 66], symresack [50, 51], and orbitope [9, 57, 58]; these constraints\nhave only been able to handle symmetries of binary variables and enforce symmetry\nreductions based on a scheme that is determined before the solving process starts.\n2. The propagation method orbital fixing [70, 75] to handle symmetries of binary variables;\nthe corresponding symmetry reduction scheme is determined dynamically during the\nsolving process.\n3. Schreier-Sims table cuts (SST cuts) [64, 82], which are cutting planes that are added\nto the MILP/MINLP and can handle symmetries of arbitrary variable types.\nNote that the first two classes are not compatible with each other due to the different\nsymmetry handling schemes.\nSCIP 9.0 features an implementation of a generalization of the first two classes of\nmethods as discussed in [95]. This generalization allows to also handle symmetries of\nnon-binary variables and to apply both classes simultaneously. At the time of adding\nthis new feature, the performance of SCIP improved by 5.90 % on the MIPLIB 2017\nbenchmark test set; on the hard instances that take at least 1000.00 s to be solved, the\n6\nrunning time even improved by 25.40 %.\n3.1.2 Symmetry Detection\nIn previous versions of SCIP, symmetries could only be detected if all types of constraints\npresent in an MILP or MINLP are known by SCIP, i.e., constraints whose correspond-\ning constraint handler is part of the SCIP release. In particular, this means that no\nsymmetries could be detected and automatically handled by SCIP in the presence of\ncustom constraints. For SCIP 9.0, the symmetry detection mechanism has been restruc-\ntured. Constraint handlers now support two optional callbacks CONSGETPERMSYMGRAPH\nand CONSGETSIGNEDPERMSYMGRAPH that allow constraint handlers to inform SCIP about\nsymmetries of their constraints. The former is used for the detection of permutation\nsymmetries, whereas the latter allows to detect signed permutation symmetries that\nwe define below. During run time, SCIP checks whether the constraint handlers of\nall constraints present in a problem implement the new callbacks. If this is the case,\nsymmetries are detected; otherwise, symmetry detection is disabled.\nDetection of Permutation Symmetries\nAs briefly explained above, permutation symme-\ntries of an MILP or MINLP can be detected by finding automorphisms of a suitable colored\ngraph, which we call the symmetry detection graph. In the following, we explain this mech-\nanism and how it can be implemented using the CONSGETPERMSYMGRAPH callback. We illus-\ntrate the ideas using the simple MILP max {y+z : −2w+2x+3y+3z ≤ 4, y, z ∈ {0, 1}}.\nTo detect symmetries, every constraint defines its own local symmetry detection graph.\nSuch a graph contains a colored node for every variable that is present in the constraint\nas well as further colored nodes and edges that model dependencies between the different\nvariables. The graph for a constraint qualifies as a symmetry detection graph for SCIP if\nit is connected and the restriction of every color-preserving automorphism to the variable\nnodes corresponds to a permutation symmetry of the corresponding constraint. Moreover,\ntwo symmetry detection graphs are only allowed to be isomorphic if their constraints are\nequivalent.\nA possible symmetry detection graph for our exemplary MILP is shown in Figure 1a.\nThe nodes for variables y and z receive the same color since both have the same objective\ncoefficient and bounds; the remaining variable nodes receive different colors, since they\nare not symmetric to each other. Moreover, we introduce one node for the right-hand\nside, which is colored according to the right-hand side coefficient. The edges connect the\nvariable nodes with the right-hand side node; they are colored according to the coefficient\nof the corresponding variable in the linear constraint. This construction can easily be\nextended to general linear constraints, see [81].\nThe symmetry detection graphs for individual constraints are then combined into\na single symmetry detection graph. The callback CONSGETPERMSYMGRAPH provides a\npointer to this graph and different functions can be used add nodes and edges to this\n“global” symmetry detection graph. To avoid re-defining variable nodes for different\nconstraints, these nodes cannot be added within the callback. Instead, these nodes are\ndefined centrally by SCIP and are colored according to the variable’s type, its objective\ncoefficient, and lower and upper bound. To make sure that only constraints of the same\ntype can be symmetric to each other (compare the permutation π above), every constraint\nshould add a “constraint” node to its local symmetry detection graph, which serves as\nan identifier of the type of constraint (e.g., “linear”, “knapsack”, or “SOS1”).\nThe functions for adding nodes to the global graph are SCIPaddSymgraphValnode(),\nSCIPaddSymgraphOpnode(), and SCIPaddSymgraphConsnode(). The first function adds\nnodes that hold a numerical value, e.g., the right-hand side node of a linear constraint.\nThe second function can be used to add “operator” nodes that allow to model special\nrelations between other nodes. For example, in a nonlinear constraint such an operator\n7\nw\nx\ny\nz\nrhs\ncons\n(a) permutation symmetries\nw\n−w\nx\n−x\ny\n−y\nz\n−z\nrhs\ncons\n(b) signed permutation symmetries\nFigure 1: Illustration of examplary symmetry detection graphs.\ncould model (nonlinear) functions that are applied to other nodes (e.g., variables).\nOperators are encoded as integer numbers, i.e., the implementation needs to make sure\nthat only equivalent operators are assigned the same integer value. The third function\nadds a node that stores a pointer to the corresponding constraint.\nEdges can be added by SCIPaddSymgraphEdge(). To add edges to variable nodes,\nthe function SCIPgetSymgraphVarnodeidx() can be used to get the index of the variable\nnode in the symmetry detection graph.\nDetection of Signed Permutation Symmetries\nLet e1, . . . , en be the standard unit vectors\nin Rn. A signed permutation is a bijective map γ : {±e1, . . . , ±en} → {±e1, . . . , ±en}\nthat satisfies γ(−ei) = −γ(ei) for all i ∈ [n].\nA signed permutation γ acts on a\nvector x ∈ Rn as γ(x) = (sgn(γ−1(1)) x|γ−1(1)|, . . . , sgn(γ−1(n)) x|γ−1(n)|), where sgn(·)\nis the sign function. That is, it permutes the entries of the vector, but it can also change\nthe sign of some entries. Signed permutation symmetries of an MILP or MINLP can be\ndefined analogously to permutation symmetries. Such symmetries arise, e.g., in geometric\nproblems like packing circles into a box [19], where they model reflections along standard\nhyperplanes.\nTo detect signed permutation symmetries, constraint handlers need to implement\nthe callback CONSGETSIGNEDPERMSYMGRAPH. The functionality is analogous to the one of\nCONSGETPERMSYMGRAPH, however, the automorphisms of the symmetry detection graph\nneed to encode signed permutation symmetries now. This can be achieved by introducing\nnot only a node for every variable x, but also for every negated variable −x. The colors of\nthe negated variables are derived based on the negated objective coefficient and negated\nbounds of variable x. Moreover, to indicate that x and −x form a pair of negated\nvariables, both must be connected by an edge in the symmetry detection graph. Finally,\nthe definition of signed permutations above requires that only reflections along standard\nhyperplanes are allowed. In SCIP’s implementation, however, also reflections along\ntranslated standard hyperplanes can be detected. This is achieved by not defining the\ncolors based on the original variable bounds, but for variables whose domain is translated\nto be centered at the origin (except for semi-unbounded variables). Consequently, also\nbinary variables may admit signed permutation symmetries since the variable domain is\ntranslated to {− 1\n2, + 1\n2}.\nFigure 1b shows the symmetry detection graph for our illustrative example. Next to\nthe classical permutation symmetry that exchanges y and z, also the signed permutation\nthat maps variable w onto variable −x can be detected.\nTo create the symmetry detection graph for signed permutation symmetries all\nfunctions to add nodes and edges as described above can be used. To access the index of\na negated variable, SCIPgetSymgraphNegatedVarnodeidx() needs to be used.\nVia the parameter propagating/symmetry/symtype a user can select which type of\nsymmetries is detected. A value of 0 corresponds to permutation symmetries, and a\nvalue of 1 to signed permutation symmetries. By default, signed permutation symmetries\nare not detected, because currently only basic symmetry handling techniques for such\nsymmetries are implemented.\n8\n3.1.3 Symmetry Interfaces\nTo detect automorphisms of the previously mentioned symmetry detection graphs, the\nprevious version of SCIP made use of the graph automorphism software bliss [55],\nwhich is also shipped together with SCIP. SCIP 9.0 also features interfaces to nauty/-\ntraces [74]. Depending on which software package shall be used for symmetry detection,\nthe SCIP make command takes SYM={none,bliss,nauty} as argument.\nMoreover,\nSCIP 9.0 allows to make use of sassy [6], which preprocesses the symmetry detection\ngraphs to accelerate the computation of symmetries. sassy can be used by compiling\nSCIP with option SYM={sbliss,snauty}.\n3.2 Nonlinear Handlers\nNonlinear constraints (see (2)) are handled by the constraint handler nonlinear in\nSCIP. This constraint handler can delegate tasks on detecting and exploiting structure\nin algebraic expressions to specialized nonlinear handlers, see [10] for details.\nFor\nexample, the nonlinear handler for quotient expressions identifies expression of the\nform vw−1 (where v and w can be arbitrary expressions) in nonlinear handlers and\nprovides specialized bound tightening and linear under/overestimators for the function\n(v, w) 7→ vw−1.\nWith SCIP 9.0, a new nonlinear handler for signomial functions has been added and\nthe nonlinear handler for quadratic expressions has been improved. In addition, a new\nnonlinear handler callback has been added to request the linearization of an expression\nin a given solution point. The nonlinear constraint handler can use this callback to\ntighten the linear relaxation when a new feasible solution has been found (parameter\nconstraints/nonlinear/linearizeheursol, currently disabled by default).\n3.2.1 Signomial Handler\nAn n-variate signomial term is defined as xα = Q\nj∈[n] xαj\nj , where α ∈ Rn and x > 0.\nIn general, the signomial term is nonconvex. In SCIP 9.0, a new nonlinear handler is\nimplemented that generates cutting planes for signomial constraints.\nGiven xα, the handler aims at approximating the lifted set S := {(x, t) ∈ Rn × R :\nt = xα}, which is in general given by a constraint of the extended formulation (see the\n8.0.0 release report [10] for details on extended formulations). It is easy to show that S\ncan be rewritten in the form\nS = {(u, v) ∈ Rh+ℓ\n+\n: u\n¯β = v¯γ}.\n(3)\nwith ¯β, ¯γ containing only nonnegative entries.\nGiven a point (˜u, ˜v), the handler outer approximates either S1 := {(u, v) ∈ Rh+ℓ\n+\n:\nu ¯β ≤ v¯γ} or S2 := {(u, v) ∈ Rh+ℓ\n+\n: u ¯β ≥ v¯γ} by checking which of the two sets does not\ncontain (˜u, ˜v). More precisely, if (˜u, ˜v) /∈ S1, then the handler separates a linear valid\ninequality for S1 that (possibly) cuts off (˜u, ˜v) and overestimates the signomial term; if\n(˜u, ˜v) /∈ S2, then the handler separates a linear valid inequality for S2 that (possibly) cuts\noff (˜u, ˜v) and underestimates the signomial term. In the case of an inequality constraint,\nonly one of the sets S1, S2 correctly describes the feasible set of the constraint, and thus\nonly one set is considered for separation.\nThe above formulation exhibits symmetry between u and v. We only illustrate the\nmethod to approximate S1, and the similar result applies to S2 as well.\nSince the signomial terms u ¯β, v¯γ are nonnegative over Rh\n+, Rℓ\n+, we can take any\npositive power η ∈ R>0 on both sides of (3) to obtain\nS1 = {(u, v) ∈ Rh+ℓ\n+\n: uβ ≤ vγ},\n(4)\n9\nwhere β := η ¯β, ¯γ := η¯γ, and η = 1/ max(P\nj∈[h]|¯βj|, P\nj∈[ℓ]|¯γj|). Thus, we have that\nmax(P\nj∈[h]|βj|, P\nj∈[ℓ]|γj|) = 1.\nMoreover, we assume that the range of u is a hyperrectangle U ⊆ Rh\n>0, which is\nusually available as variable bounds in SCIP. The reformulated set enjoys two useful\nproperties [100]: the terms uβ, vγ in (4) are concave functions, and the convex envelope of\nuβ over U is vertex polyhedral. The signomial handler aims at (1) linearizing the convex\nenvelope of uβ, i.e., an affine underestimator for uβ, and (2) linearizing the concave\nfunction vγ.\nLet Q be the vertices of U. Since the convex envelope of uβ over U is vertex polyhedral,\nthe separation of an affine underestimator a · u + b could be solved by an LP:\nmax\na∈Rh,b∈R{a · ˜u + b : ∀q ∈ Q a · q + b ≤ qγ},\n(5)\nWhen h = 1, 2, the handler directly uses a closed form expression of the optimal a, b\nwithout solving the LP [100].\nNow, denote g(v) := vγ. Since g is concave, a straightforward way to overestimate it\nis to use the gradient at ˜v and obtain g(˜v) + ∇g(˜v) · (v − ˜v). Then, the separated valid\ninequality is of the form a · u + b ≤ g(˜v) + ∇g(˜v) · (v − ˜v). In the implementation, such\ninequality is further transformed into an overestimator of xα through scaling.\nTable 3 shows the impact of the signomial handler on SCIP performance on 152\nMINLPLib instances that contain signomial terms.\nWe report the ratio of shifted\ngeometric means of time and nodes and the number of solved instances.\nTable 3: Performance statistics of the signomial handler over SCIP default.\n152 selected MINLPLib instances\nTime (s)\nNodes\nSolved\n0.92\n0.93\n78 vs 75\nThe computational cost of estimating a signomial term primarily stems from solv-\ning the LP (5), whose size is exponential in h.\nAn advanced parameter that gov-\nerns the maximum allowable value of h that the signomial handler can manage is\nnlhdlr/signomial/advanced/maxnundervars. Currently, the signomial handler is dis-\nabled by default. Users can enable it via the nlhdlr/signomial/enabled parameter.\nThe current implementation of the signomial handler lacks a specialized bound\ntightening method for variables within signomial terms. Given the critical impact of\nvariable range (U) on cut quality, a further development of the handler involves refining\nthese bounds through propagation techniques.\n3.2.2 Strengthening Cuts for Quadratic Expressions\nTo separate nonconvex quadratic constraints, the constraint handler nlhdlr quadratic,\nwhich was introduced in SCIP 8.0, can generate intersection cuts by setting the parame-\nter nlhdlr/quadratic/useintersectioncuts = TRUE (currently disabled by default).\nUntil now, the intersection cuts were built by using only the current LP relaxation\nand the violated quadratic constraint. To additionally leverage integrality information,\nSCIP 9.0 allows to strengthen the cutting planes using monoidal strengthening [8] if\nsome of the variables in the problem need to be integer. As [15] showed, the strengthened\nintersection cuts significantly outperform the pure intersection cuts whenever monoidal\nstrengthening can be applied.\n10\n3.3 Primal Heuristics\n3.3.1 Indicatordiving\nSemi-continuous variables are variables that take either the value 0 or any value within\na specific range:\nx ∈ {0} ∪ [ℓ, u] with 0 < ℓ ≤ u and u ∈ R+ ∪ ∞.\nSuch variables are used, for example, in modeling supply chains where a facility either\ncan produce nothing or, if enabled, has to produce at least an amount ℓ.\nSemi-continuous variables can be formulated in SCIP with an additional binary\nvariable z ∈ {0, 1} as\nx ∈ [0, u],\nℓz ≤ x,\n(6)\nz = 0 =⇒ x ≤ 0.\n(7)\nThereby, (7) is a so-called indicator constraint, that is, x ≤ 0 must hold if z = 0. Linear\nconstraint (6) models the lower bound on x.\nIf u is finite, one can reformulate the indicator constraint (7) with a linear big-M\nconstraint, such as x ≤ uz. If u is infinite, this is not directly possible. However, one\ncould add an artificial upper bound with the risk of cutting off optimal solutions and\ncausing numerical issues due to the large upper bound M. A new diving heuristic,\nindicatordiving, has been developed to find solutions also in the presence of indicator\nconstraints modeling semi-continuous variables with infinite upper bounds u.\nDiving heuristics iteratively fix variables and solve the modified LPs simulating a\ndepth-first-search in an auxiliary tree. A description of the generic diving procedure used\nin SCIP can be found in [39]. Other diving heuristics in SCIP typically take only integer\nvariables with fractional LP solution value into account. In contrast, indicatordiving\nadditionally examines all binary indicator variables z corresponding to violated indicator\nconstraints and which are integral in the LP solution but not fixed already.\nEach such variable is assigned a score to determine the variable that should be fixed\nnext. For indicator variables, the score is given by\nϕ :=\n(\n−1,\nif ˆx ∈ {0} ∪ [ℓ, u],\n100 · (ℓ − ˆx)/ℓ,\nif ˆx ∈ (0, u),\nwhere ˆx is the current LP solution value. The indicator variable z with the highest score\ngets fixed to 1 if the LP value ˆx is at least 50% of the lower bound ℓ. Otherwise, it gets\nfixed to 0. As soon as all the indicator variables are integral in the LP solution or all the\nindicator constraints are fulfilled, other candidate variables are considered, for which the\nscore and rounding direction of farkasdiving are used.\n3.3.2 Extension of Dynamic Partition Search\nSince SCIP 7.0, the decomposition information can be passed to SCIP in addition to\nthe instance, which can be leveraged in heuristics, for example. A detailed description of\ndecompositions and their handling in SCIP can be found in the release report for that\nversion [33].\nDynamic Partition Search (DPS) introduced in SCIP 8.0 is a heuristic that requires\na decomposition.\nDPS splits an MILP (1) into several subproblems according to a\ndecomposition. Thereby, the linking constraints and their right-/left-hand sides are\nalso split by introducing new parameters pq for each block q, called partition. Such a\n11\npartition is central to the DPS. When the heuristic is called during node preprocessing,\nthe partition is initialized with a uniform distribution of the constraint sides over the\nblocks.\nIn SCIP 9.0, the DPS has been extended with an option to get called at the end\nof the node processing and, therefore, can use the LP solution for initialization of the\npartition. The parameter heuristics/dps/timing controls the calling point and, thus,\nthe initialization. A detailed description of DPS and additional heuristics exploiting\ndecomposition information can be found in [44].\n3.3.3 Learning to Control Primal Heuristics Online\nSince the performance of heuristics is highly problem-dependent and most of them can be\nvery costly, it is necessary to handle them strategically. Thus, sometimes it is preferable\nto have dynamic, self-improving procedures rather than relying on static methods to\ncontrol primal heuristics.\nSCIP has already used two adaptive heuristics in previous versions that use bandit\nalgorithms to decide which heuristics to additionally run: Adaptive Large Neighborhood\nSearch (ALNS) [45] and Adaptive Diving [46]. Building upon this, SCIP 9.0 now includes\na general online learning approach [14], which dynamically adapts the application of\nprimal heuristics to the unique characteristics of the current instance. In particular, both\nLarge Neighborhood Search and Diving heuristic types are controlled together, making\nthis the first work where two different classes of heuristics are treated simultaneously by\na single learning agent. In SCIP 9.0, this is implemented as a heuristic called scheduler.\nSince this framework was designed to replace the classical heuristic handling as a whole\nas opposed to being run as an additional heuristic, scheduler is disabled by default in\nSCIP 9.0.\n3.4 Cutting Planes\nThis section discusses the updates to the separation routine in SCIP, both for cut\ngeneration and cut selection. Separation in SCIP is performed in rounds. In a round,\nvarious valid inequalities that cut off the current LP relaxation’s fractional solution are\ngenerated and stored either in a global cut pool (for cuts that are valid globally) or a\nseparation store (for cuts that are valid only locally). Then, these cuts are filtered and\nadded to the LP relaxation before re-solving the relaxation and proceeding to the next\nround of separation. Note that other components of SCIP such as branching maybe\nexecuted in between two separation rounds. These rounds are performed until a stopping\ncriterion is met (e.g., maximum number of rounds or cuts added, or dual bound of the\nrelaxation stalling).\n3.4.1 Cut Generation\nLagromory Separator\nThere are two potential issues with the round-based approach\nmentioned above.\n1. The generation of higher-ranked cuts, e.g., higher-ranked Gomory Mixed-Integer\n(GMI) cuts [18], may result in numerical troubles during the solving process.\n2. Multiple rounds of separation may be needed to achieve dual bound improvement in\nthe presence of dual degeneracy [34].\nThe first issue is addressed in the literature via a relax-and-cut framework-based separation\ntechniques [43, 68, 12, 28]. The second issue has received less attention until now despite\nbeing critical to the usefulness of separation in the solvers.\nThe new separator in\n12\nSCIP, the Lagromory separator, addresses both these issues.\nIt is a relax-and-cut\nframework-based separator which is built based on the separation technique presented\nin [28].\nIn the basic version of the relax-and-cut framework, which is also discussed in [28],\nwhen a separator is called at a node with fractional LP solution, certain cuts are generated\nbut not added directly to the LP relaxation. These cuts are added to the objective\nfunction of the node LP in a Lagrangian fashion using Lagrangian (penalty) multipliers.\nThen, this Lagrangian dual problem is solved via an iterative approach by updating\nthe Lagrangian multipliers in every iteration, requiring an LP solving in every iteration.\nWhen an LP is solved in an iteration, it is equivalent to exploring a new basis of the node\nLP. Then, additional cuts are generated with respect to this newly explored basis and are\nadded to the objective function of the node LP again. This procedure is repeated until\ncertain termination criterion is met. While this approach in [28] was proven to improve\nthe dual bound at a given single node, it turned out to be ineffective in the context of\nthe entire branch-and-cut tree. To overcome this crucial hurdle, the Lagromory separator\nin SCIP also implements various novel enhancements.\n− Theoretical enhancements include stabilization and regularization of the vector of\nLagrangian multipliers. This vector is integral to and iteratively updated in the\nrelax-and-cut framework. Stabilization using a core vector is an essential component\nin the literature of decomposition methods such as the Benders’ and Dantzig-Wolfe\ndecompositions. Regularization of vectors (e.g., by projecting the vectors into ℓ1,\nℓ2, etc, norm balls) is a commonly applied technique in the literature of nonlinear\noptimization.\n− Computational enhancements include the threshold for dual degeneracy beyond which\nthe separator is executed; the working limits on the number of LP iterations, number\nof cuts generated per explored basis of the LP relaxation; etc.\nThe separator was tested on the MIPLIB 2017 benchmark library [40]. It speeds up\nthe solving process of harder instances that require at least 1000 seconds for solving to\noptimality. On the other hand, it increases the solving time for many easier instances\nresulting in no overall improvement of the default SCIP performance. The Lagromory\nseparator is OFF by default due to this reason. An interested user may switch it ON by\nchanging the parameter separation/lagromory/freq to a non-negative number.\n3.4.2 Cut Selection\nThe cut selector plugin introduced in SCIP 8.0 enabled multiple research directions\non the problem of cut selection, which recently underwent a revived scrutiny. The\npreviously hard-coded algorithm was replaced by the default cut selector cutsel/hybrid,\nwhich in particular scores cuts with a weighted sum of four criteria: efficacy, integer\nsupport, objective parallelism, and directed cutoff distance (with the last one having a\nzero default weight). The scored cuts are then filtered iteratively by an orthogonality\ncriterion. This removes all non-orthogonal cuts (within some tolerance), starting from\nthe highest-scoring cut until every cut has been processed, and the remaining set of cuts\nis pairwise near-orthogonal. The importance of cut selection and some limitations of the\ncurrent criteria were in particular shown theoretically and computationally in [94, 92].\nThese lines of work point to the conclusion that the current cut selection algorithm\nfails to capture and adapt to important instance properties. In [90], a new cut selector\ncoined ensemble was developed to capture more of these properties than the current\nweighted sum of the default cutsel/hybrid. The three core aspects of the cut selection\nloop described above are the filtering of cuts, their scoring, and the stopping criteria\nfor the cut loop. All three aspects were extended and modified in the new ensemble cut\nselector, resulting in a large number of parameters that were activated and adjusted\n13\nα\nα\nA\nx∗\n1\nα\nx∗\n2\nd1\nd2\nI : aT\n1 x ≤ b1\nII : aT\n2 x ≤ b2\na2\na1\n(a)\nα\nA\nx∗\nα\nd\nPII\nPI\nI : aT\n1 x ≤ b1\nII : aT\n2 x ≤ b2\nα1\n(b)\nFigure 2: (a) Pairwise cut efficacies, shown for two cases of LP solutions in\nyellow and green for cutting planes I and II. (b) Orthogonality-based cutfiltering,\nshown by the offset between the pairwise efficacies in red and gray of cut I paired\nwith either cut II or the orthogonally rotated cut II.\nthrough the blackbox hyperparameter optimization tool SMAC [65]. These parameters\ninclude pseudo-cost based cut scoring, sparsity based cut scoring, density based cut\nfiltering, parallelism based scoring penalties, and a stopping criterion based on the number\nof nonzeros in the added cuts. Because of the filter on cut density, cutsel/ensemble\nperforms unreliably on MINLPs, where some nonlinear constraints demand the use\nof high-density cuts for good solver performance. It is therefore applied with a lower\npriority than cutsel/hybrid which remains the default, but can be activated by changing\ncutselection/ensemble/priority to a number greater than 8000, the value of hybrid.\nFurther, a novel dynamic filtering method is introduced in cutsel/dynamic, which\naims to enhance the current near-orthogonal threshold methodology used in the cutsel/hybrid\nselector. The geometric rationale for this approach can be understood by considering\nhow the LP improvements for a pair of cutting planes, in terms of efficacy, are influenced\nby the position of their intersection relative to the current LP optimal solution x∗ (refer\nto Figure 2a).\nThis is exemplified by demonstrating that a mere summation of individual cut\nefficacies can be misleading in evaluating the actual efficacy of a pair of cuts. The true\nefficacy, indicated by red arrows in Figure 2a, represents the minimal distance between\nthe feasible region A and the current LP solution post-application.\nFigure 2a illustrates a fundamental issue when using pure efficacy to evaluate multiple\ncuts simultaneously. This underscores the motivation for orthogonality-based filtering as\nshowcased in Figure 2b. Specifically, if the current LP solution is outside the fan formed\nby the intersection of the cuts (yellow), then one of the cuts becomes entirely ineffective,\nprovided that the vertex created by this pair is not the optimal point in the subsequent\niteration. Conversely, if the LP solution is within this fan, the aggregated efficacy of the\ncuts does not accurately reflect their true effectiveness. This discrepancy is due to the\ndegree of non-orthogonality between the cuts.\nTo address these limitations, the stringent orthogonality threshold of the default\nselector was relaxed. The new dynamic criterion is depending on individual cut efficacies\nand aims to position the LP solution within the intersection fan of the cut pairs (as\ndepicted in Figure 2b). Additionally, users can specify a minimum efficacy improvement\nrelative to the previous cutting plane via the mingain parameter.\nThe filtermode\nparameter ’f’ in cutsel/dynamic facilitates rescoring of cuts between filtering rounds,\nusing the pairwise efficacy instead of the usual scoring mechanism. Preliminary test\nresults have not indicated a general improvment over the default cut selection; hence,\nthis selector is assigned a lower priority than cutsel/hybrid as well.\n14\n3.5 Branching\nSCIP 9 introduces a new branching criterion both implemented as a stand-alone rule and\nintegrated within the default hybrid branching rule [4]. For a more thorough overview of\nthe results and idea presented in this section, see [91].\n3.5.1 GMI Branching\nGMI cuts [42] are a standard tool for solving MILPs. It is recommended to see [7, 17, 91]\nfor an overview of how GMI cuts are derived and applied in practice. The motivation\nto use GMI cuts to influence branching decisions stems from the observation that GMI\ncuts are derived from a split disjunction. A split disjunction is defined by an integer\nπ0 ∈ Z and an integral vector π ∈ Zp × {0}n−p, which has zero entries for coefficients of\ncontinuous variables. The disjunction is then given by:\n{x ∈ Rn | πT\n0 x ≤ π0} ∪ {x ∈ Rn | πT\n0 x ≥ π0 + 1}.\nSince no integer point is contained in the split {x ∈ Rn | π0 < πT\n0 x < π0}, all feasible\npoints lie in the above split disjunction. Thus, a cut that only cuts off points from the\ncontinuous relaxation that are inside the split is valid for the original problem. Such cuts\nare called split cuts and GMI cuts are a special case of this family of cutting planes. An\nexample split with a valid split cut is visualized in Figure 3.\nFigure 3: Example intersection cut that is also a split cut.\nTo best link GMI cuts and branching, note that for π = ei and π0 = ⌊¯xi⌋, where ei\ndenotes the i-th unit vector and ¯x the current LP solution, the split corresponds exactly\nto the region that is excluded by branching on a fractional variable xi, i ∈ I. The simple\nlogic of this branching rule is then the following: Variables whose splits would generate a\ndeep cut might also be good branching candidates. Therefore, the new Gomory branching\nrule generates all GMI cuts (or up to some maximum number of candidates if set), and\nbranches on the variable whose associated split produces the most efficacious GMI cut.\n3.5.2 Using GMI Cuts for Reliability Pseudo-Cost (Hybrid) Branching\nThe default branching rule of SCIP [4] has been extended to include two new terms in\nthe weighted sum scoring rule. Currently, the variable that is branched on by SCIP is\nthe one with the highest branching score (ignoring cases of epsilon-close results). The\nscore for each variable is computed via a weighted sum rule that combines the following\nmeasures:\n− The frequency that the variable appears in a conflict\n− The average length of the conflicts that the variable appears in\n15\n− The frequency that the variable’s branching history has resulted in other variables\nbecoming fixed\n− The frequency that the variable’s branching history has resulted in infeasible sub-\nproblems\n− The number of NL constraints the variable features in\n− The pseudo-cost associated with the variable from its history of previous branching\ndecisions.\nThis weighted sum rule is appended with two terms controlled by the weight parame-\nters gmiavgeffweight and gmilasteffweight. In a separation round, SCIP now stores\nthe normalized efficacy of generated GMI cuts. The normalization is a simple division\nby the largest efficacy of any GMI cut generated in the separation round, resulting in\na value in the range [0, 1] for each variable from which the tableau row produced a\nGMI cut. For each variable in the problem, SCIP now records a running average of the\nnormalized GMI cut efficacies from tableau rows associated with the respective variable.\nAdditionally, SCIP now also records the last normalized value for each variable. The\nparameter gmiavgeffweight is then the weight of the running average in the weighted\nsum rule for each variable. The parameter gmiavgeffweight is equivalently the weight\nof the most recent recorded value for each variable. By default, gmiavgeffweight is set\nto 0, and gmilasteffweight is set to 10−5, effectively acting as a tie-breaker.\n3.6 LP Interfaces\nHiGHS LPI\nSCIP 9.0 provides the possibility of using the open-source LP solver\nHiGHS [54] 2 . The interface provides the basic functionality, yet it does not fully exploit\nall capabilities of HiGHS.\n3.7 Technical Improvements\nAMPL .nl reader\nAdded support for logical constraints in binary variables and basic\nlogical operators (and, or, not, equal).\nOBBT propagator\nVariables of linear constraints that are controlled by indicator con-\nstraints can now also be taken into account for bound tightening. This feature is disabled\nby default, but can be enabled via parameter propagating/obbt/indicators.\n4 SoPlex\nMost importantly, SoPlex 6.0 now supports incremental precision boosting [26] for\nsolving LPs exactly over the rational numbers, in addition to and in combination with the\nexisting LP iterative refinement approach [38, 37]. The algorithm for exact solving can be\nselected using the boolean parameters precision boosting and iterative refinement.\nBy default, both are set to true, in which case SoPlex uses a combined algorithm with\nan outer precision boosting loop and an inner iterative refinement loop. For further details\nand computational experiments we refer to [25]. The new default for exact, rational LP\nsolving increases the robustness of the algorithm on numerically challenging problems\nand allows to solve more problems exactly. Furthermore, a new Python interface for\nSoPlex 6.0, called PySoPlex, has been developed, see Section 6.7.\n2Available in source code at https://github.com/ERGO-Code/HiGHS.\n16\n5 PaPILO\nPaPILO, a C++ library, is a solver-independent presolving library that provides pre-\nsolving routines for MIP and LP and is part of the presolving routines in SCIP. It\nalso supports multi-precision arithmetic, which makes PaPILO an essential part of the\npresolving process of ExactSCIP [27], the numerically exact version of SCIP [16, 23, 24].\nPaPILO 2.2 now supports proof logging as a new feature, i.e., the generation of\nmachine-verifiable certificates by a solver in order to prove the correctness of its compu-\ntation. Proof logging was originally introduced by the SAT community to ensure the\ncorrectness of a solver’s computation, since even state-of-the-art solvers falsely claim\ninfeasibility or optimality or return infeasible “solutions” [5, 16, 59, 88, 36]. Examples of\nsuch proof formats are DRAT [96, 47, 48], GRIT [21], and LRAT [20]. ExactSCIP has\nadapted proof logging to certify the branch-and-cut process using the Vipr format [13],\nbut since Vipr currently does not provide the necessary functionality to verify presolving\nreductions, ExactSCIP only prints the certificate for the presolved problem.\nAs a first step, PaPILO 2.2 provides the ability to generate proofs for presolving\nof binary programs in the VeriPB format3, which was developed for Pseudo-Boolean\n(PB) problems [11, 41]. VeriPB readily supports a reverse unit propagation rule and a\nredundancy-based strengthening rule for verifying dual arguments, and in our effort to\ncertify presolving transformations, it has recently been extended by an objective update\nrule to support modification of the objective during presolving. We refer to [49] for a\ndetailed explanation of how each presolving reduction in PaPILO can be certified using\nthe VeriPB language. In order to print a certificate in PaPILO the boolean parameter\nverification_with_veripb must be set to true. Since VeriPB only supports PB\nproblems, proof logging is currently only supported for this problem class.\nTable 4 reports the performance impact of proof logging. These experiments are based\non the selection of binary programs from MIPLIB 2017 [40], called MIPLIB 01 [22], and\nthe instances of the PB16 competition [79], each split into optimization (opt) and decision\n(dec) instances. We only exclude the large-scale instances ivu06-big and supportcase11\nwith a runtime of more than 2 hours in PaPILO. Times are aggregated using the\ngeometric mean shifted by 1 second. The overhead of proof logging ranges from 27%\nto 54% on both test sets. For 99% of the decision instances, the overhead per applied\ntransaction is below 0.186 milliseconds on both test sets. This shows the viability of\nproof logging in practice especially considering that proof logging runs sequentially while\nthe presolvers in PaPILO run in parallel.\nTest set\ninstances\ndefault (in seconds)\nw/proof log (in seconds)\nrelative\nPB16-dec\n1398\n0.050\n0.077\n1.54\nMIPLIB 01-dec\n295\n0.498\n0.631\n1.27\nPB16-opt\n532\n0.439\n0.565\n1.29\nMIPLIB 01-opt\n144\n0.337\n0.473\n1.40\nTable 4: Runtime comparison of PaPILO with and without proof logging.\n6 Interfaces\n6.1 AMPL\nThe AMPL4 interface of SCIP now supports parameters specified in AMPL command\nscripts via option scip options. The value of scip options is expected to be a sequence\n3available at https://gitlab.com/MIAOresearch/software/VeriPB\n4https://www.ampl.com\n17\nof parameter names and values, separated by a space, for example\noption scip_options ’limits/time 10 display/verblevel 1’;\n6.2 JSCIPOpt\nThe Java interface to SCIP, JSCIPOpt, is again actively maintained and requires a\nC++ compiler (rather than just a C compiler) to compile. The following functionality of\nthe SCIP C API (or the objscip C++ API) is newly available from Java:\n− branch priorities,\n− concurrent solving,\n− changing the objective coefficient of a variable (contributed by the GitHub user\nxunzhang (Hong Wu)),\n− message handlers (using the objscip API – the C++ interface class can be transpar-\nently subclassed from Java),\n− getting the current dual bound,\n− getting the solving status (contributed by the GitHub user patrickguenther),\n− interrupting the solving process,\n− creating a partial solution (contributed by the GitHub user fuookami (Sakurakouji\nSakuya)).\nIn addition, the following bugs were fixed:\n− running SWIG during the compilation only worked on *nix systems due to the\nunnecessary use of the external POSIX command mv,\n− building against SCIP 8.0.0 or newer was failing due to a missing #include statement,\n− even when defining SCIP DIR at build time, a different SCIP could be silently used if\nthe passed SCIP DIR was not valid for some reason (this is now an error),\n− a JSCIPOpt library dynamically linked to the SCIP library was not binary-\ncompatible with different versions of SCIP due to the use of macros hardcoding\nstructure layouts (macros now are avoided unless SCIP is statically linked into\nJSCIPOpt),\n− the SCIP Longint type was incorrectly mapped to a 32-bit Java type (now correctly\nmapped to a 64-bit Java type).\n6.3 PySCIPOpt\nThe Python interface to SCIP, PySCIPOpt [69], is now automatically shipped with\na standard installation of SCIP when installed using PyPI. This automatic SCIP\ninstallation is currently available only for machines running x86 64 architecture. The\nPython versions and OS combinations supported include CPython 3.6+ for manylinux2014\n(includes Ubuntu / Debian) and MacOS, and CPython 3.8+ for Windows. Linking\nPySCIPOpt against a custom installation of SCIP is still possible and encouraged,\nhowever now requires cloning PySCIPOpt’s repository, available on GitHub [77], and\ninstalling from source.\nA new Python package, PySCIPOpt-ML [93], is now available. The package uses\nPySCIPOpt to automatically formulate machine learning models into MIPs. This func-\ntionality allows users to easily optimize MIPs with embedded ML constraints, simplifying\nthe process of deciding on a formulation and extracting the relevant information from\nthe machine learning model.\n18\n6.4 SCIP.jl\nSCIP.jl is the Julia interface to SCIP and provides access to the solver in two ways.\nFirst, it provides an access to all functions of the C interface mirrored by Clang.jl\nand accessed via Julia ccall. Second, it exposes a high-level interface implementing the\nMathOptInterface API [62] and callable, e.g., through the JuMP modeling language\n[67]. The high-level interface now includes an access to the heuristic, branching, and cut\nselection plugins, making them available in an idiomatic Julia style, in addition to the\nconstraint handler and separator plugins. The heuristic and cut generation plugins are\nalso available through the standardized MathOptInterface callback mechanism.\n6.5 russcip\nWith SCIP 9.0, we introduce the first version of the Rust interface for SCIP, russcip\n[80]. The interface builds on Rust’s solid foundation for type and memory safety. Being\na system’s programming language, it allows for low-level access to the C-API of SCIP,\nbinding directly without the need for copying data across the language barrier. The\ninterface is split into two parts: an unsafe part, which provides full access to the C-API\nthrough the module ffi and a limited but safe wrapper that allows access to part of the\nAPI. Currently, the following plugins are implemented on the safe interface that allow\nyou to addi custom branching rules, primal heuristics, and variable pricers, and control\nSCIP through event handlers, all designed to guarantee compliance with SCIP’s return\ntypes at compile-time.\nThe interface is still in its early stages and we are working on adding more plugins\nand improving the ergonomics of the safe interface. The following is a small example of\nhow to use russcip:\nuse russcip::prelude::*;\nfn main() {\n// Create model\nlet mut model = Model::default()\n.hide_output()\n.set_obj_sense(ObjSense::Maximize);\n// Add variables\nlet x1 = model.add_var(0., f64::INFINITY, 3., \"x1\", VarType::Integer);\nlet x2 = model.add_var(0., f64::INFINITY, 4., \"x2\", VarType::Integer);\n// Add constraint \"c1\": 2 x1 + x2 <= 100\nmodel.add_cons(vec![x1.clone(), x2.clone()],\n&[2., 1.], -f64::INFINITY, 100., \"c1\");\nlet solved_model = model.solve();\nlet status = solved_model.status();\nprintln!(\"Status:{:?}\", status);\nlet obj_val = solved_model.obj_val();\nprintln!(\"Objective:{}\", obj_val);\nlet sol = solved_model.best_sol().unwrap();\nlet vars = solved_model.vars();\n19\nfor var in vars {\nprintln!(\"{}={}\",&var.name(), sol.val(var));\n}\n}\nFurther examples related to defining and using custom plugins can be found in the\nrepository’s [80] tests.\n6.6 SCIP++\nSCIP++ is a C++ wrapper for SCIP’s C interface. It automatically manages the\nmemory, provides a simple interface to create linear expressions and inequalities, and\nprovides type-safe methods to set parameters. It can be used in combination with SCIP’s\nC interface, especially for features not yet present in SCIP++. The following is a small\nexample.\n#include <scippp/model.hpp>\nusing namespace scippp;\nint main() {\nModel model(\"Simple\");\nauto x1 = model.addVar(\"x_1\", 1);\nauto x2 = model.addVar(\"x_2\", 1);\nmodel.addConstr(3 * x1 + 2 * x2 <= 1, \"capacity\");\nmodel.setObjsense(Sense::MAXIMIZE);\nmodel.solve();\n}\n6.7 PySoPlex\nPySoPlex [78] is a newly-introduced Python wrapper for SoPlex’s C interface. The\ninstallation process is similar to that of PySCIPOpt, so, a user needs to install SoPlex\nfirst, set the SOPLEX DIR environment variable, and then install the PySoPlex wrapper.\nThe installation process has been successfully tested on Linux and Mac OS platforms.\nThe following is a small example.\nimport pytest\nfrom pysoplex import Soplex, INTPARAM, BOOLPARAM, VERBOSITY\n# create solver instance\ns = Soplex()\n# read instance file, solve LP, and get objective value\nsuccess = s.readInstanceFile(\"PATH_TO_INSTANCE.mps.gz\")\n# specify \"lifting\" parameter\ns.setBoolParam(BOOLPARAM.LIFTING, 1)\n# specify \"verbosity\" level\ns.setIntParam(INTPARAM.VERBOSITY, VERBOSITY.ERROR)\ns.optimize()\nobj_val = s.getObjValueReal()\nprint(obj_val)\n20\n7 The UG Framework\nUG was originally designed to parallelize powerful state-of-the-art branch-and-bound\nbased solvers (we call these “base solvers”). Two of the most intensively developed\nparallel solvers are FiberSCIP (for a shared memory computing environment) and\nParaSCIP (for a distributed computing environment), both using SCIP as the base\nsolver. ParaSCIP solved two open instances on a supercomputer from MIPLIB (MI-\nPLIB2003) for the first time in 2010 [85]. To achieve this, supercomputer jobs had to\nbe restarted frequently from snapshots of the branch-and-bound tree. To verify the\nresults, we aimed to solve the instances with a single job on the supercomputer, which\nrequired the development of new features and intense debugging of ParaSCIP. Since\ndebugging on distributed environments is inefficient, FiberSCIP was developed, which\nhas the same parallelization algorithms as that of ParaSCIP (since UG abstracts the\nparallelization library), but can run on a single PC. The results of FiberSCIP were\nfirst presented in the MIPLIB2010 paper [61] (therein, FiberSCIP is referred to as\nUG[SCIP/SPX]). Even though FiberSCIP was already working in 2010, the FiberSCIP\npaper [87] was submitted only 3 years later, since the software went through intensive\ntests. The supplement of the FiberSCIP paper includes only a small fraction of the\ncomputational results we had conducted. Due to the major debugging effort of UG and\nSCIP via FiberSCIP, ParaSCIP could solve more than 20 open instances [86] from\nMIPLIB and none of these results have been proven wrong so far. Thus, next to its main\npurpose of parallelization, a major contribution of UG has been an improved stability\nof SCIP. For example, complete thread-safety of SCIP was only achieved due to the\ndevelopment of FiberSCIP.\nSince UG provides a systematic way to parallelize a state-of-the-art sequential or\nmulti-threaded solver to run on a large scale distributed memory environment, with\nversion 1.0, UG is generalized to a software framework for a high-level task parallelization\nframework5. That is, with version 1.0, UG will not only parallelize the tree search of\nbranch-and-bound based solvers, but allow the parallelization of other kind of solvers.\nOn top of that, UG version 1.0 will also allow more flexibility and customization when\nparallelizing a branch-and-bound based solver for a specific purpose. For an example, see\nthe recent adaptation CMAP-LAP (Configurable Massively Parallel solver framework for\nLAttice Problems) of UG to solve lattice problems [89].\nWith the new beta version of UG 1.0, which is released with the SCIP Optimization\nSuite 9.0, UG has caught up with interface changes in SCIP and includes a few more\nbugfixes. It does not include many new features. However, the possibility to appropriately\nspecify an optimality gap limit has been added.\n7.1 Setting optimality gap limit\nFor FiberSCIP/ParaSCIP, SCIP parameters can be set by using command line\noptions,“-sl, -sr, -s” as below:\n../bin/fscip\nsyntax: ../bin/fscip fscip_param_file problem_file_name [-l <logfile>] [-q]\n[-sl <settings>]\n[-s <settings>] [-sr <root_settings>] [-w <prefix_warm>]\n[-sth <number>] [-fsol <solution_file>] [-isol <initial solution file]\n-l <logfile>\n: copy output into log file\n-q\n: suppress screen messages\n-sl <settings>\n: load parameter settings (.set) file for LC presolving\n-s <settings>\n: load parameter settings (.set) file for solvers\n5For concept of UG’s high-level task parallelization framework, see https://ug.zib.de/doc-1.0.0/\nhtml/CONCEPT.php\n21\n-sr <root_settings>\n: load parameter settings (.set) file for root\n-w <prefix_warm>\n: warm start file prefix ( prefix_warm_nodes.gz and\nprefix_warm_solution.txt are read )\n-sth <number>\n: the number of solver threads used\n-fsol <solution file> : specify output solution file\n-isol <intial solution file> : specify initial solution file\nTherefore, parallel solving algorithms of FiberSCIP/ParaSCIP can be controlled\njust by setting these parameters. The optimality gap limit could be set by using the “-s”\noption. However, using default settings, FiberSCIP/ParaSCIP executes presolving in\nthe LoadCoordinator, which is the controller thread (process) of FiberSCIP (ParaSCIP,\nrespectively), and the presolved instance is passed on to all solvers [87]. Therefore, the\n“-s” option applies to solving the presolved instance, not the original one. This can be\na problem when trying to set a gap limit, for instance. With a previous release, a UG\nparameter was added to handle this appropriately, but it turned out to not work well\nand has now been removed again. Instead, with this version, an optimality gap limit\ncan be set for the original instance. To do so, the gap limit should be set in the SCIP\nparameter setting file that is specified with the “-sl” option. The LoadCoordinator will\nthen handle the gap limit appropriately.\n8 The GCG Decomposition Solver\nGCG is an extension that turns SCIP into a branch-and-price or branch-and-Benders-\ncut solver for mixed-integer linear programs. GCG can automatically detect a model\nstructure that allows for a Dantzig-Wolfe reformulation or Benders decomposition. The\nreformulation process and the corresponding algorithmics like Benders cut and column\ngeneration is done automatically without interaction from the users. They just need\nto provide the model. The latest version is GCG 3.6. Here are the few changes since\nversion 3.5 upon which we reported along with SCIP version 8.0.\nGCG 3.6 mainly contains code base improvements, with no major algorithmic changes.\nMost importantly for developers, the API has mildly changed: The prefix DEC was\nreplaced with GCG to achieve a consistent naming.\nThe model structures detected by GCG are called decompositions. The detection\nprocess itself was described in the SCIP 6.0 release report.\nPart of this process is\nbased on classifiers which group constraints and variables for their potential roles in a\ndecomposition. From the usually many decompositions found, users can select manually\nor let GCG select based on different scores. The score implementation was refactored:\nPreviously, it was cumbersome to add user-defined scores to GCG, but with GCG 3.6,\nnew scores can be added as plugins. Each score must provide a function that calculates\na score value for a (partial) decomposition. The macro GCG DECL SCORECALC is provided\nto declare the method that implements the scoring and is automatically called by GCG.\nThe display dialog command has been extended and can now be used to print\ninformation about registered scores and classifiers. Furthermore, GCG 3.6 now supports\ncompiling with Microsoft Visual C++ (MSVC) and it is possible to use CMake to simplify\nthe build process.\nThe Python interface PyGCGOpt mirrors the above changes.\nUsers can now\ncustomize the detection process even more by adding own classifiers and scores.\n22\n9 SCIP-SDP\nSCIP-SDP is a solver for handling mixed-integer semidefinite programs, w.l.o.g, written\nin the following form\ninf\nb⊤y\ns.t.\nm\nX\nk=1\nAk yk − A0 ⪰ 0,\nℓi ≤ yi ≤ ui\n∀ i ∈ [m],\nyi ∈ Z\n∀ i ∈ I,\n(8)\nwith symmetric matrices Ak ∈ Rn×n for i ∈ {0, . . . , m}, b ∈ Rm, ℓi ∈ R ∪ {−∞},\nui ∈ R ∪ {∞} for all i ∈ [m] := {1, . . . , m}. The set of indices of integer variables is given\nby I ⊆ [m], and M ⪰ 0 denotes that a matrix M is positive semidefinite.\nSCIP-SDP uses an SDP-based branch-and-bound approach based on SCIP (default).\nIt also supports the possibility to use linear inequalities in an LP-based approach. Which\none is faster, depends on the instance.\nThe development of SCIP-SDP proceeded along a series of dissertations: Mars [71],\nGally [29], and Matter [72]. Corresponding articles are [30] (existence of Slater points in\nbranch-and-bound, dual fixing) and [73] (presolving techniques). In the following, we\ngive an overview of the main changes since version 4.0.0, which was reported on in the\nSCIP 8 report. The current version of SCIP-SDP is 4.3.0.\n9.1 Symmetry Handling of MISDPs\nOne can handle permutation symmetries of (8) in the sense of Section 3.1. We will sketch\nhow this works and refer to [52] for details.\nTo define symmetries of (8), for a matrix A ∈ Rn×n and a permutation σ of [n], let\nσ(A)ij := Aσ−1(i),σ−1(j)\n∀ i, j ∈ [n].\nDefinition 9.1.1. A permutation π of variable indices [m] is a formulation symmetry\nof (8) if there exists a permutation σ of the dimensions [n] such that\n1. π(I) = I, π(ℓ) = ℓ, π(u) = u, and π(b) = b\n(π leaves integer variables, variable bounds, and the objective coefficients invariant),\n2. σ(A0) = A0 and, for all i ∈ [m], σ(Ai) = Aπ−1(i).\nSuch symmetries can be detected by using graph automorphism algorithms, see [52].\nExamples of (formulation) symmetries computed for a testset of MISDP instances can\nalso be found in [52]. Note that we do not exploit symmetries in the matrix solutions of\nthe SDPs like it has been done in [35, 53], for example.\nTable 5 presents computational results – we refer to [52] for the setup and details.\nWe observe a speed-up of about 4.00 % for all instances and of about 34.00 % for the 21\ninstances that contain symmetry.\nSince the appearance of [52], SCIP-SDP has been changed to allow for using the\ncallback access to symmetry computation in SCIP, see Section 3.1.2. Thereby, we\nhave also changed the symmetry detection graph. It now only contains a single node\nfor each nonzero entry of the matrix that is connected to the ‘dimension’-nodes. The\ncorresponding graph for the following MISDP is given in Figure 1.\ninf\nn\ny1 + y2 :\n\u0010 3 1 0\n1 1 0\n0 0 0\n\u0011\ny1 +\n\u0010 0 0 0\n0 1 1\n0 1 3\n\u0011\ny2 −\n\u0010 1 0 0\n0 1 0\n0 0 1\n\u0011\n⪰ 0, 0 ≤ y1, y2 ≤ 1, y1, y2 ∈ Z\no\n.\n23\nTable 5:\nResults on a testset of 184 MISDP instances with/without using\nsymmetry handling in SCIP. We report the shifted geometric means of the\nrunning times in seconds and number of nodes. Column “symtime” and “#\ngens” report the averge time for symmetry handling (including detection) and\nnumber of generators, respectively. The “all optimal” block reports results for\nthe 168 instances that were solved by both methods. The last column gives the\nshifted geometric mean running time only for the 21 instances that contain some\nsymmetry.\nall (184)\nall optimal (168)\nonly symmetric (21)\ntime (s)\nsymtime (s)\n# gens\ntime (s)\n#nodes\ntime (s)\nwithout\n130.6\n–\n–\n95.0\n778.3\n45.07\nwith\n125.3\n0.44\n99\n90.8\n760.6\n29.84\n1\n2\n3\n(1, 1)1\n(1, 2)1\n(2, 2)1\n(2, 2)2\n(2, 3)2\n(3, 3)2\n(1, 1)0\n(2, 2)0\n(3, 3)0\ny1\ny2\nFigure 4: Illustration of symmetry detection graph.\nIn Figure 4, the colors of the nodes allow to distinguish different types and values. The\ntopmost nodes represent the dimensions. Node (i, j)k represents the symmetric entries\n(i, j) and (j, i) (or diagonal entry (i, i)) of matrix Ak. The colors of these nodes corre-\nspond to distinct coefficients in the matrices. The only non-trivial color-preserving\nautomorphism of the graph exchanges y1 ↔ y2, (1, 1)1 ↔ (3, 3)2, (1, 2)1 ↔ (2, 3)2,\n(2, 2)1 ↔ (2, 2)2, (1, 1)0 ↔ (3, 3)0, 1 ↔ 3, and keeps node 2 fixed. This leads to the\nvariable permutation π, which exchanges y1 and y2, and the matrix permutation σ, which\nexchanges 1 and 3.\n9.2 Conflict Analysis for MISDPs\nThe original idea of conflict analysis was to learn from infeasible nodes in a branch-and-\nbound-tree. To this end, Achterberg [1] transferred ideas from SAT-solving to MILPs.\nOne further way is to try to learn cuts from solutions of the duals, which is called “dual\nray/solution analysis” in Witzig et al. [98] and Witzig [97].\nTo briefly explain the application to MISDPs, consider the SDP relaxation of (8).\nGiven a positive semidefinite ˆX ∈ Rn×n, we observe that the inner product with a\npositive semidefinite matrix M ∈ Rn×n is nonnegative:\n⟨ ˆX, M⟩ :=\nn\nX\ni,j=1\nˆXij Mij ≥ 0.\nThus, defining A(y) := Pm\nk=1 Ak yi, we get\n⟨ ˆX, A(y)⟩ =\nm\nX\nk=1\n⟨ ˆX, Ak⟩ yk ≥ 0\n(9)\n24\nfor every feasible solution y of (8). Note that this is a (redundant) linear inequality in y.\nThe idea is to use it in the propagation of variable bounds and not explicitly add it\nto (8).\nThere are two natural ways to obtain good candidates for ˆX. If the relaxation is\nfeasible, we obtain a solution ( ˆX, ˆrℓ, ˆru) of the dual\nsup\n⟨A0, X⟩ + ℓ⊤rℓ − u⊤ru\ns.t.\n⟨Aj, X⟩ + rℓ\nj − ru\nj = bj\n∀ j ∈ [m],\nX ⪰ 0, rℓ, ru ≥ 0.\nSimilarly, if the relaxation is infeasible and a constraint qualification holds, one can\nobtain a dual ray satisfying\n⟨Aj, X⟩ + rℓ\nj − ru\nj = 0\n∀ j ∈ [m],\n⟨A0, X⟩ + ℓ⊤rℓ − u⊤ru > 0,\nX ⪰ 0, rℓ, ru ≥ 0.\nOne can prove that (9) is infeasible with respect to the local bounds ℓ and u and can\ntherefore provide a proof of infeasibility, see [76].\nSCIP-SDP generates a conflict constraint (9) for each feasible or infeasible node,\nstores them as constraints, and performs bound propagation. This leads to a speed-up\nand node reduction of about 8% on the same testset used in the previous section. We\nrefer to [76] for more details.\n9.3 Further Changes\nSimilar to SCIP, the license of SCIP-SDP has changed to Apache 2.0.\nSeveral improvements have been made to speed up some of the presolving methods.\nOne can use ARPACK instead of Lapack for eigenvalue computations (use ARPACK\n= true when using makefiles); this is usually slower for the typical sizes of MISDPs.\nMoreover, when running the LP-based approach (misc/solvesdps = 0), now CMIR\ninequalities are generated by default. To implement conflict analysis, the handling of\ndual solutions has been extended and improved.\n10 Final Remarks\nThe SCIP Optimization Suite 9.0 release provides new functionality along with improved\nperformance and reliability. In SCIP, the changes to the symmetry detection feature\ninclude new techniques for handling symmetries of non-binary variables, restructuring\nof the mechanism to detect symmetries of the custom constraints, and detection of\nthe signed permutation symmetries.\nNew interfaces to nauty [74] as well as the\npreprocessor sassy [6] have been added. A new nonlinear handler for signomial functions\nand improvements to the existing nonlinear handler for quadratic expressions were\nimplemented. A new diving heuristic for handling indicator constraints that are used to\nrepresent the semi-continuous variables, an extension of the dynamic partition search\nheuristic, and a new adaptive heuristic that dynamically adapts the application of large\nneighborhood search and diving heuristics to the characteristics of the current instance\nwere also implemented. Furthermore, a new separator called the Lagromory separator for\ngenerating potentially lower-ranked cuts and reducing the dual bound stalling due to the\ndual degeneracy, and two new cut selection schemes were included: cutsel/ensemble\nthat adapts with respect to the given instance properties and cutsel/dynamic that aims\n25\nto enhance the near-orthogonal threshold methodology used in the default cut selection\nscheme. A new branching criterion called the GMI branching was implemented. It\nis available both as a stand-alone rule and also integrated within the default hybrid\nbranching rule of SCIP. It considers a new scoring component based on the GMI cuts\ncorresponding to the fractional variable in a given LP solution. Finally, a new interface\nto the HiGHS LP solver along with technical improvements to the AMPL reader and\nOBBT propagator were implemented.\nRegarding usability, various interfaces were improved and new interfaces were added.\nThe AMPL interface to SCIP was extended to support parameters from the AMPL\ncommand scripts. The Java interface to SCIP, JSCIPOpt, is being maintained actively\nand was extended with new functionality. The Python interface to SCIP, PySCIPOpt,\ncan now be fully installed using PyPI. A new Python package, PySCIPOpt-ML, is\navailable to automatically formulate machine learning models into MIPs. The Julia\ninterface to SCIP, SCIP.jl, was extended to be able to access additional plugins of\nSCIP. Two new interfaces to SCIP, Rust interface called russcip and C++ interface\ncalled SCIP++, are also available, along with a new Python interface to SoPlex called\nPySoPlex.\nThe LP solver SoPlex now supports incremental precision boosting for exact LP\nsolving over the rational numbers. It is available as a stand-alone as well as in combination\nwith the existing LP iterative refinement approach. The presolving library PaPILO now\nhas a new feature called proof logging that allows the generation of machine-verifiable\ncertificates for presolving of binary problems to be able to prove the correctness of the\ncomputations. The parallel framework UG now has a new beta version of UG 1.0 that\nincludes the latest interface changes of SCIP along with new bugfixes. A new feature to\nappropriately set the gap limit has also been added. The GCG decomposition solver\nnow includes improvements to its code base, can be compiled with Microsoft Visual C++\n(MSVC), and supports CMake as a build system. The SCIP extension SCIP-SDP has\nbeen improved to include new symmetry handling techniques and conflict analysis for\nMISDPs, along with other improvements in its presolving methods and cut generation\ntechniques.\nThese developments yield an overall performance improvement of both MILP and\nMINLP benchmarking instances. SCIP 9.0 is able to solve 19 more MILP instances as\ncompared to SCIP 8.0 with a speedup of 2% on the affected instances. This speedup\nfurther increases to 6% when only the hard instances requiring at least 1000 seconds by\nat least one setting are considered. The number of nodes required for MILPs that were\nsolved by both versions of SCIP also reduce considerably by 17% in SCIP 9.0. These\nperformance gains are more prominent for MINLPs. SCIP 9.0 solves 5 more MINLP\ninstances as compared to SCIP 8.0 with performance improvements of 4% in time (for\nall MINLPs) and 13% in the number of nodes (for the MINLPs that were solved by both\nthe versions of SCIP). When looking at hard instances requiring at least 1000 seconds\nby at least one setting, the gains are further increased to 20% and 46% in time and\nnumber of nodes, respectively. Furthermore, when restrcited to nonconvex instances\nonly, SCIP 9.0 is faster by 8%. Hence, SCIP 9.0 has become faster and more reliable as\ncompared to SCIP 8.0.\nAcknowledgements\nThe authors want to thank all previous developers and contributors to the SCIP Opti-\nmization Suite and all users that reported bugs and often also helped reproducing and\nfixing the bugs. Thanks to Herman Appelgren, Gerald Gamrath, Stephen J. Maher,\nDaniel Rehfeldt, and Michael Winkler, for various contributions. Thanks to Julian Hall\nfor supporting the creation of the HiGHS LP interface.\n26\nContributions of the Authors\nThe material presented in the article is highly related to code and software. In the\nfollowing, we try to make the corresponding contributions of the authors and possible\ncontact points more transparent.\n− JvD implemented the generalization of symmetry handling methods for binary vari-\nables to general variables (Section 3.1.1).\n− CH implemented the symmetry detection framework via symmetry detection graph\ncallbacks in constraint handlers (Section 3.1.2).\n− MP implemented the interface to nauty, and the interface to allow sassy as prepro-\ncessor for bliss (Section 3.1.3).\n− MP and GM implemented the interface to allow sassy as preprocessor for nauty\n(Section 3.1.3).\n− LX implemented the nonlinear handler for signomial functions (Section 3.2.1).\n− AC and FeS implemented monoidal strengthening for quadratic constraints (Sec-\ntion 3.2.2).\n− KH and AH implemented the indicator diving heuristic (Section 3.3.1).\n− KH extended the DPS heuristic (Section 3.3.2).\n− AC implemented the online scheduling procedure of primal heuristics (Section 3.3.3).\n− SB implemented the Lagromory separator (Section 3.4.1).\n− MT and MB worked on the ensemble cut selector (Section 3.4.2).\n− CG worked on cut statistics and dynamic cut selection (Section 3.4.2).\n− MT and MB worked on the GMI branching and hybrid branching improvements\n(Section 3.5.1 and Section 3.5.2).\n− AG, GM, and AH developed the HiGHS LP interface (Section 3.6).\n− SV extended the AMPL .nl reader (Section 3.7).\n− KH extended the OBBT propagator (Section 3.7).\n− LE worked on the SoPlex solver (Section 4).\n− AH implemented the proof-logging in PaPILO (Section 5).\n− SV extended the AMPL interface (Section 6.1).\n− KK is the current maintainer of JSCIPOpt and has worked on the developments listed\nin Section 6.2 (other than the ones where different developer names are mentioned).\n− JD actively maintained and contributed to PySCIPOpt (Section 6.3).\n− MT worked on the pip installation of PySCIPOpt through PyPI (Section 6.3).\n− MB worked on the Julia interface SCIP.jl (Section 6.4).\n− MG implemented the russcip interface (Section 6.5).\n− IH programmed the initial release of SCIP++ (Section 6.6).\n− SB implemented the PySoPlex interface (Section 6.7).\n− YS worked on the UG framework (Section 7)\n− Concerning GCG (Section 8), EM and JL refactored and improved the code (general\nAPI changes and scores) and added the MSVC support; JL and TD extended\nPyGCGOpt.\n− CH and MP implemented symmetry handling for SCIP-SDP and MP implemented\nconflict analysis in SCIP-SDP (Section 9).\n27\n− RvdH contributed to various bug fixes and file reader updates.\n− DK fixed several bugs and contributed to other fixes regarding reliability. Furthermore,\nDK implemented an algorithm to simplify the debugging process by generating a\npotentially smaller-sized instance and settings that can reproduce the bugs faster.\n− JM and FrS worked on the continuous integration system, regular testing, binary\ndistributions, and website development. JM is the contact person for these aspects.\nReferences\n[1] T. Achterberg. Conflict analysis in mixed integer programming. Discrete Opt., 4(1):4–20,\n2007. doi:10.1016/j.disopt.2006.10.006.\n[2] T. Achterberg. Constraint Integer Programming. Dissertation, Technische Universit¨at\nBerlin, 2007.\n[3] T. Achterberg. SCIP: Solving Constraint Integer Programs. Mathematical Programming\nComputation, 1(1):1–41, 2009. doi:10.1007/s12532-008-0001-1.\n[4] T. Achterberg and T. Berthold. Hybrid branching. In Integration of AI and OR Techniques\nin Constraint Programming for Combinatorial Optimization Problems: 6th International\nConference, Proceedings of CPAIOR 2009 Pittsburgh, PA, USA, 2009, pages 309–311.\nSpringer, 2009.\n[5] ¨O. Akg¨un, I. P. Gent, C. Jefferson, I. Miguel, and P. Nightingale. Metamorphic testing\nof constraint solvers. In Proceedings of the 24th International Conference on Principles\nand Practice of Constraint Programming (CP ’18), volume 11008 of Lecture Notes in\nComputer Science, pages 727–736. Springer, 2018.\n[6] M. Anders, P. Schweitzer, and J. Stieß. Engineering a preprocessor for symmetry detection.\nIn L. Georgiadis, editor, 21st International Symposium on Experimental Algorithms, SEA\n2023, July 24-26, 2023, Barcelona, Spain, volume 265 of LIPIcs, pages 1:1–1:21, 2023.\ndoi:10.4230/LIPICS.SEA.2023.1.\n[7] K. Andersen, G. Cornu´ejols, and Y. Li. Reduce-and-split cuts: Improving the performance\nof mixed-integer gomory cuts. Management Science, 51(11):1720–1732, 2005.\n[8] E. Balas and R. G. Jeroslow. Strengthening cuts for mixed integer programs. European\nJournal of Operational Research, 4(4):224–234, 1980.\n[9] P. Bendotti, P. Fouilhoux, and C. Rottner. Orbitopal fixing for the full (sub-)orbitope and\napplication to the unit commitment problem. Mathematical Programming, 186:337–372,\n2021. doi:10.1007/s10107-019-01457-1.\n[10] K. Bestuzheva, M. Besan¸con, W.-K. Chen, A. Chmiela, T. Donkiewicz, J. van Doornmalen,\nL. Eifler, O. Gaul, G. Gamrath, A. Gleixner, L. Gottwald, C. Graczyk, K. Halbig, A. Hoen,\nC. Hojny, R. van der Hulst, T. Koch, M. L¨ubbecke, S. J. Maher, F. Matter, E. M¨uhmer,\nB. M¨uller, M. E. Pfetsch, D. Rehfeldt, S. Schlein, F. Schl¨osser, F. Serrano, Y. Shinano,\nB. Sofranac, M. Turner, S. Vigerske, F. Wegscheider, P. Wellner, D. Weninger, and\nJ. Witzig. The SCIP Optimization Suite 8.0. Technical report, Optimization Online, 2022.\nhttps://optimization-online.org/?p=18429.\n[11] B. Bogaerts, S. Gocht, C. McCreesh, and J. Nordstr¨om. Certified dominance and symmetry\nbreaking for combinatorial optimisation. Journal of Artificial Intelligence Research, 77:\n1539–1589, 2023.\n[12] V. F. Cavalcante, C. C. de Souza, and A. Lucena. A relax-and-cut algorithm for the set\npartitioning problem. Computers & operations research, 35(6):1963–1981, 2008.\n[13] K. K. H. Cheung, A. M. Gleixner, and D. E. Steffy. Verifying integer programming\nresults. In Proceedings of the 19th International Conference on Integer Programming and\nCombinatorial Optimization (IPCO ’17), volume 10328 of Lecture Notes in Computer\nScience, pages 148–160. Springer, 2017.\n[14] A. Chmiela, P. Lichoki, A. Gleixner, and S. Pokutta. Online learning for scheduling\nMIP heuristics. In International Conference on Integration of Constraint Programming,\nArtificial Intelligence, and Operations Research, pages 114–123. Springer, 2023.\n28\n[15] A. Chmiela, G. Mu˜noz, and F. Serrano.\nMonoidal strengthening and unique lifting\nin MIQCPs. In International Conference on Integer Programming and Combinatorial\nOptimization, pages 87—-99. Springer, 2023.\n[16] W. Cook, T. Koch, D. E. Steffy, and K. Wolter. A hybrid branch-and-bound approach for\nexact rational mixed-integer programming. Mathematical Programming Computation, 5\n(3):305–344, 2013.\n[17] G. Cornu´ejols.\nValid inequalities for mixed integer linear programs.\nMathematical\nprogramming, 112(1):3–44, 2008.\n[18] G. Cornu´ejols, F. Margot, and G. Nannicini. On the safety of Gomory cut generators.\nMathematical Programming Computation, 5:345–395, 2013.\n[19] A. Costa, P. Hansen, and L. Liberti. On the impact of symmetry-breaking constraints on\nspatial branch-and-bound for circle packing in a square. Discrete Applied Mathematics,\n161(1):96–106, 2013. doi:10.1016/j.dam.2012.07.020.\n[20] L. Cruz-Filipe, M. J. H. Heule, W. A. Hunt Jr., M. Kaufmann, and P. Schneider-Kamp.\nEfficient certified RAT verification. In Proceedings of the 26th International Conference on\nAutomated Deduction (CADE-26), volume 10395 of Lecture Notes in Computer Science,\npages 220–236. Springer, 2017.\n[21] L. Cruz-Filipe, J. P. Marques-Silva, and P. Schneider-Kamp. Efficient certified resolu-\ntion proof checking. In Proceedings of the 23rd International Conference on Tools and\nAlgorithms for the Construction and Analysis of Systems (TACAS ’17), volume 10205 of\nLecture Notes in Computer Science, pages 118–135. Springer, 2017.\n[22] J. Devriendt. MIPLIB 0-1 instances in OPB format. Dataset on Zenodo, 2020.\n[23] L. Eifler and A. Gleixner.\nA computational status update for exact rational mixed\ninteger programming. In M. Singh and D. P. Williamson, editors, Integer Programming\nand Combinatorial Optimization, pages 163–177, Cham, 2021. Springer International\nPublishing.\n[24] L. Eifler and A. Gleixner. Safe and verified gomory mixed integer cuts in a rational MIP\nframework. SIAM Journal on Optimization, 2023. accepted for publication.\n[25] L. Eifler, J. Nicolas-Thouvenin, and A. Gleixner. Combining precision boosting with LP\niterative refinement for exact linear optimization. Preprint 2311.08037, arXiv, 2023. URL\nhttps://arxiv.org/abs/2311.08037.\n[26] D. G. Espinoza. On Linear Programming, Integer Programming and Cutting Planes. PhD\nthesis, Georgia Institute of Technology, 2006.\n[27] Exact SCIP.\nA development version of scip with exact rational arithmetic.\nhttps:\n//github.com/scipopt/scip/tree/exact-rational, 2024.\n[28] M. Fischetti and D. Salvagnin. A relax-and-cut framework for Gomory mixed-integer cuts.\nMathematical Programming Computation, 3:79–102, 2011.\n[29] T. Gally. Computational Mixed-Integer Semidefinite Programming. Dissertation, TU\nDarmstadt, 2019.\n[30] T. Gally, M. E. Pfetsch, and S. Ulbrich.\nA framework for solving mixed-integer\nsemidefinite programs.\nOptimization Methods and Software, 33(3):594–632, 2018.\ndoi:10.1080/10556788.2017.1322081.\n[31] G. Gamrath and M. E. L¨ubbecke. Experiments with a generic Dantzig-Wolfe decomposition\nfor integer programs.\nIn P. Festa, editor, Experimental Algorithms, volume 6049 of\nLecture Notes in Computer Science, pages 239–252. Springer Berlin Heidelberg, 2010.\ndoi:10.1007/978-3-642-13193-6 21.\n[32] G. Gamrath, T. Koch, S. J. Maher, D. Rehfeldt, and Y. Shinano. SCIP-Jack—a solver for\nSTP and variants with parallelization extensions. Mathematical Programming Computation,\n9(2):231–296, 2017. doi:10.1007/s12532-016-0114-x.\n[33] G. Gamrath, D. Anderson, K. Bestuzheva, W.-K. Chen, L. Eifler, M. Gasse, P. Gemander,\nA. Gleixner, L. Gottwald, K. Halbig, G. Hendel, C. Hojny, T. Koch, P. L. Bodic, S. J.\nMaher, F. Matter, M. Miltenberger, E. M¨uhmer, B. M¨uller, M. E. Pfetsch, F. Schl¨osser,\nF. Serrano, Y. Shinano, C. Tawfik, S. Vigerske, F. Wegscheider, D. Weninger, and\nJ. Witzig. The SCIP Optimization Suite 7.0. Technical report, Optimization Online, 2020.\nhttp://www.optimization-online.org/DB_HTML/2020/03/7705.html.\n29\n[34] G. Gamrath, T. Berthold, and D. Salvagnin. An exploratory computational analysis\nof dual degeneracy in mixed-integer programming. EURO Journal on Computational\nOptimization, 8(3-4):241–261, 2020.\n[35] K. Gatermann and P. Parrilo. Symmetry groups, semidefinite programs, and sums of\nsquares. Journal of Pure and Appl. Algebra, 192(1-3):95–128, 2004.\n[36] X. Gillard, P. Schaus, and Y. Deville. SolverCheck: Declarative testing of constraints. In\nProceedings of the 25th International Conference on Principles and Practice of Constraint\nProgramming (CP ’19), volume 11802 of Lecture Notes in Computer Science, pages 565–582.\nSpringer, 2019.\n[37] A. Gleixner and D. E. Steffy. Linear programming using limited-precision oracles. Mathe-\nmatical Programming, 183:525–554, 2020. doi:10.1007/s10107-019-01444-6.\n[38] A. Gleixner, D. E. Steffy, and K. Wolter. Iterative refinement for linear programming.\nINFORMS Journal on Computing, 28(3):449–464, 2016. doi:10.1287/ijoc.2016.0692.\n[39] A. Gleixner, M. Bastubbe, L. Eifler, T. Gally, G. Gamrath, R. L. Gottwald, G. Hendel,\nC. Hojny, T. Koch, M. E. L¨ubbecke, S. J. Maher, M. Miltenberger, B. M¨uller, M. E.\nPfetsch, C. Puchert, D. Rehfeldt, F. Schl¨osser, C. Schubert, F. Serrano, Y. Shinano,\nJ. M. Viernickel, M. Walter, F. Wegscheider, J. T. Witt, and J. Witzig. The SCIP\nOptimization Suite 6.0. Technical report, Optimization Online, 2018. URL http://www.\noptimization-online.org/DB_HTML/2018/07/6692.html.\n[40] A. Gleixner, G. Hendel, G. Gamrath, T. Achterberg, M. Bastubbe, T. Berthold,\nP. Christophel, K. Jarck, T. Koch, J. Linderoth, M. L¨ubbecke, H. Mittelmann, D. Ozyurt,\nT. Ralphs, D. Salvagnin, and Y. Shinano. MIPLIB 2017: Data-driven compilation of the\n6th Mixed-Integer Programming Library. Mathematical Programming Computation, 13:\n443–490, 2021. doi:10.1007/s12532-020-00194-3.\n[41] S. Gocht, R. Martins, J. Nordstr¨om, and A. Oertel.\nCertified CNF translations for\npseudo-Boolean solving. In Proceedings of the 25th International Conference on Theory\nand Applications of Satisfiability Testing (SAT ’22), volume 236 of Leibniz International\nProceedings in Informatics (LIPIcs), pages 16:1–16:25, 2022.\n[42] R. Gomory. An algorithm for the mixed integer problem. Technical report, RAND CORP\nSANTA MONICA CA, 1960.\n[43] M. Guignard. Efficient cuts in Lagrangean ‘relax-and-cut’ schemes. European Journal of\nOperational Research, 105(1):216–223, 1998.\n[44] K. Halbig, A. G¨oß, and D. Weninger. Exploiting user-supplied decompositions inside heuris-\ntics. Technical report, Optimization Online, 2023. URL https://optimization-online.\norg/?p=23386.\n[45] G. Hendel. Adaptive large neighborhood search for mixed integer programming. Mathe-\nmatical Programming Computation, 14(2):185–221, 2022.\n[46] G. Hendel, M. Miltenberger, and J. Witzig. Adaptive algorithmic behavior for solving\nmixed integer programs using bandit algorithms. In International Conference on Operations\nResearch, pages 513–519. Springer, 2018.\n[47] M. J. H. Heule, W. A. Hunt Jr., and N. Wetzler. Trimming while checking clausal proofs.\nIn Proceedings of the 13th International Conference on Formal Methods in Computer-Aided\nDesign (FMCAD ’13), pages 181–188, 2013.\n[48] M. J. H. Heule, W. A. Hunt Jr., and N. Wetzler. Verifying refutations with extended\nresolution. In Proceedings of the 24th International Conference on Automated Deduction\n(CADE-24), volume 7898 of Lecture Notes in Computer Science, pages 345–359. Springer,\n2013.\n[49] A. Hoen, A. Oertel, A. Gleixner, and J. Nordstr¨om. Certifying MIP-based presolve\nreductions for 0-1 integer linear programs. Preprint, arXiv, 2024. URL https://arxiv.\norg/abs/2401.09277.\n[50] C. Hojny. Packing, partitioning, and covering symresacks. Discrete Applied Mathematics,\n283:689–717, 2020. doi:10.1016/j.dam.2020.03.002.\n[51] C. Hojny and M. E. Pfetsch. Polytopes associated with symmetry handling. Mathematical\nProgramming, 175(1):197–240, 2019. doi:10.1007/s10107-018-1239-7.\n[52] C. Hojny and M. E. Pfetsch. Handling symmetries in mixed-integer semidefinite programs.\n30\nIn A. A. Cire, editor, Integration of Constraint Programming, Artificial Intelligence, and\nOperations Research, pages 69–78, Cham, 2023. Springer. doi:10.1007/978-3-031-33271-5 5.\n[53] H. Hu, R. Sotirov, and H. Wolkowicz. Facial reduction for symmetry reduced semidefinite\nand doubly nonnegative programs. Mathematical Programming, 2022. To appear.\n[54] Q. Huangfu and J. Hall. Parallelizing the dual revised simplex method. Mathematical\nProgramming Computation, 10:119–142, 2015. doi:10.1007/s12532-017-0130-5.\n[55] T. Junttila and P. Kaski. bliss: A tool for computing automorphism groups and canonical\nlabelings of graphs. http://www.tcs.hut.fi/Software/bliss/, 2012.\n[56] V. Kaibel and A. Loos. Finding descriptions of polytopes via extended formulations and\nliftings. In A. R. Mahjoub, editor, Progress in Combinatorial Optimization. Wiley, 2011.\n[57] V. Kaibel and M. E. Pfetsch. Packing and partitioning orbitopes. Mathematical Program-\nming, 114(1):1–36, 2008. doi:10.1007/s10107-006-0081-5.\n[58] V. Kaibel, M. Peinhardt, and M. E. Pfetsch. Orbitopal fixing. Discrete Optimization, 8\n(4):595–610, 2011. doi:10.1016/j.disopt.2011.07.001.\n[59] E. Klotz. Identification, assessment, and correction of ill-conditioning and numerical\ninstability in linear and integer programs. In A. Newman and J. Leung, editors, Bridging\nData and Decisions, TutORials in Operations Research, pages 54–108. INFORMS, 2014.\ndoi:10.1287/educ.2014.0130.\n[60] T. Koch. Rapid Mathematical Prototyping. Dissertation, Technische Universit¨at Berlin,\n2004.\n[61] T. Koch, T. Achterberg, E. Andersen, O. Bastert, T. Berthold, R. E. Bixby, E. Danna,\nG. Gamrath, A. M. Gleixner, S. Heinz, A. Lodi, H. Mittelmann, T. Ralphs, D. Salvagnin,\nD. E. Steffy, and K. Wolter. Miplib 2010. Mathematical Programming Computation,\n3(2):103–163, 2011. doi:10.1007/s12532-011-0025-9. URL https://doi.org/10.1007/\ns12532-011-0025-9.\n[62] B. Legat, O. Dowson, J. D. Garcia, and M. Lubin. MathOptInterface: a data structure for\nmathematical optimization problems. INFORMS Journal on Computing, 34(2):672–689,\n2022.\n[63] L. Liberti. Symmetry in mathematical programming. In J. Lee and S. Leyffer, editors,\nMixed Integer Nonlinear Programming, volume 154 of IMA Series, pages 236–286. Springer,\nNew York, 2012.\n[64] L. Liberti and J. Ostrowski. Stabilizer-based symmetry breaking constraints for mathe-\nmatical programs. Journal of Global Optimization, 60:183–194, 2014. doi:10.1007/s10898-\n013-0106-6.\n[65] M. Lindauer, K. Eggensperger, M. Feurer, A. Biedenkapp, D. Deng, C. Benjamins,\nT. Ruhkopf, R. Sass, and F. Hutter. SMAC3: A versatile Bayesian optimization package\nfor hyperparameter optimization. Journal of Machine Learning Research, 23(54):1–9, 2022.\nURL http://jmlr.org/papers/v23/21-0888.html.\n[66] A. Loos. Describing Orbitopes by Linear Inequalities and Projection Based Tools. Disser-\ntation, Otto-von-Guericke-Universit¨at Magdeburg, 2010.\n[67] M. Lubin, O. Dowson, J. D. Garcia, J. Huchette, B. Legat, and J. P. Vielma. Jump 1.0:\nrecent improvements to a modeling language for mathematical optimization. Mathematical\nProgramming Computation, pages 1–9, 2023.\n[68] A. Lucena. Non delayed relax-and-cut algorithms. Annals of Operations Research, 140:\n375–410, 2005.\n[69] S. Maher, M. Miltenberger, J. P. Pedroso, D. Rehfeldt, R. Schwarz, and F. Serrano.\nPySCIPOpt: Mathematical programming in Python with the SCIP optimization suite. In\nMathematical Software – ICMS 2016, pages 301–307. Springer International Publishing,\n2016. doi:10.1007/978-3-319-42432-3 37.\n[70] F. Margot. Exploiting orbits in symmetric ILP. Mathematical Programming, 98(1–3):3–21,\n2003. doi:10.1007/s10107-003-0394-6.\n[71] S. Mars. Mixed-Integer Semidefinite Programming with an Application to Truss Topology\nDesign. Dissertation, FAU Erlangen-N¨urnberg, 2013.\n[72] F. Matter. Sparse Recovery Under Side Constraints Using Null Space Properties. Disser-\ntation, TU Darmstadt, 2022.\n31\n[73] F. Matter and M. E. Pfetsch. Presolving for mixed-integer semidefinite optimization.\nINFORMS J. Opt., 5(2):131–154, 2022. doi:10.1287/ijoo.2022.0079.\n[74] B. D. McKay and A. Piperno. Practical graph isomorphism, II. Journal of Symbolic\nComputation, 60:94–112, 2014. doi:10.1016/j.jsc.2013.09.003.\n[75] J. Ostrowski, J. Linderoth, F. Rossi, and S. Smriglio. Orbital branching. Mathematical\nProgramming, 126(1):147–178, 2011. doi:10.1007/s10107-009-0273-x.\n[76] M. E. Pfetsch. Dual conflict analysis for mixed-integer semidefinite programs. Preprint,\nOptimization Online, 2023. https://optimization-online.org/?p=23813.\n[77] PySCIPOpt.\nThe Python interface for SCIP.\nhttps://www.github.com/scipopt/\nPySCIPOpt, 2017.\n[78] PySoPlex. The python interface for SoPlex. https://www.github.com/scipopt/PySoPlex,\n2023.\n[79] O. Roussel.\nPseudo-Boolean competition 2016,\n2016.\nURL http://www.cril.\nuniv-artois.fr/PB16/.\n[80] russcip. The Rust interface for SCIP. https://www.github.com/scipopt/russcip, 2023.\n[81] D. Salvagnin. A dominance procedure for integer programming. Master’s thesis, Universt`a\ndegli studi di Padova, 2005.\n[82] D. Salvagnin. Symmetry breaking inequalities from the Schreier-Sims table. In W.-J.\nvan Hoeve, editor, Integration of Constraint Programming, Artificial Intelligence, and\nOperations Research, pages 521–529. Springer, 2018. doi:10.1007/978-3-319-93031-2 37.\n[83] SCIP++. The C++ interface for SCIP. https://www.github.com/scipopt/SCIPpp, 2023.\n[84] Y. Shinano. The Ubiquity Generator framework: 7 years of progress in parallelizing branch-\nand-bound. In N. Kliewer, J. F. Ehmke, and R. Bornd¨orfer, editors, Operations Research\nProceedings 2017, pages 143–149. Springer, 2018. doi:10.1007/978-3-319-89920-6 20.\n[85] Y. Shinano, T. Achterberg, T. Berthold, S. Heinz, and T. Koch. Parascip: A parallel\nextension of scip. In C. Bischof, H.-G. Hegering, W. E. Nagel, and G. Wittum, editors,\nCompetence in High Performance Computing 2010, pages 135–148, Berlin, Heidelberg,\n2012. Springer Berlin Heidelberg. ISBN 978-3-642-24025-6.\n[86] Y. Shinano, T. Achterberg, T. Berthold, S. Heinz, T. Koch, and M. Winkler. Solving open\nMIP instances with ParaSCIP on supercomputers using up to 80,000 cores. In 2016 IEEE\nInternational Parallel and Distributed Processing Symposium (IPDPS), pages 770–779,\n2016. doi:10.1109/IPDPS.2016.56.\n[87] Y. Shinano, S. Heinz, S. Vigerske, and M. Winkler.\nFiberSCIP: A shared mem-\nory parallelization of SCIP.\nINFORMS Journal on Computing, 30(1):11–30, 2018.\ndoi:10.1287/ijoc.2017.0762.\n[88] D. E. Steffy. Topics in exact precision mathematical programming. PhD thesis, Georgia\nInstitute of Technology, 2011. URL http://hdl.handle.net/1853/39639.\n[89] N. Tateiwa, Y. Shinano, K. Yamamura, A. Yoshida, S. Kaji, M. Yasuda, and K. Fujisawa.\nCMAP-LAP: Configurable massively parallel solver for lattice problems. ZIB-Report\n21-16, Zuse Institute Berlin, 2021.\n[90] M. Turner, T. Berthold, and M. Besan¸con. A context-aware cutting plane selection\nalgorithm for mixed-integer programming. Operations Research Proceedings (accepted),\n2023.\n[91] M. Turner, T. Berthold, M. Besan¸con, and T. Koch. Branching via cutting plane selection:\nImproving hybrid branching. arXiv preprint arXiv:2306.06050, 2023.\n[92] M. Turner, T. Berthold, M. Besan¸con, and T. Koch. Cutting plane selection with analytic\ncenters and multiregression. In International Conference on Integration of Constraint\nProgramming, Artificial Intelligence, and Operations Research, pages 52–68. Springer,\n2023.\n[93] M. Turner, A. Chmiela, T. Koch, and M. Winkler. PySCIPOpt-ML: Embedding trained\nmachine learning models into mixed-integer programs. arXiv preprint arXiv:2312.08074,\n2023.\n[94] M. Turner, T. Koch, F. Serrano, and M. Winkler. Adaptive Cut Selection in Mixed-\nInteger Linear Programming. Open Journal of Mathematical Optimization, 4:5, 2023.\ndoi:10.5802/ojmo.25.\n32\n[95] J. van Doornmalen and C. Hojny. A unified framework for symmetry handling. preprint\navailable at https://optimization-online.org/?p=20822, 2022.\n[96] N. Wetzler, M. J. H. Heule, and W. A. Hunt Jr. DRAT-trim: Efficient checking and trim-\nming using expressive clausal proofs. In Proceedings of the 17th International Conference\non Theory and Applications of Satisfiability Testing (SAT ’14), volume 8561 of Lecture\nNotes in Computer Science, pages 422–429. Springer, 2014.\n[97] J. Witzig. Infeasibilitity Analysis for MIP. Dissertation, TU Berlin, 2021.\n[98] J. Witzig, T. Berthold, and S. Heinz. Experiments with conflict analysis in mixed integer\nprogramming. In Integration of Constraint Programming, Artificial Intelligence, and\nOperations Research, CPAIOR, volume 10335 of LNCS, pages 211–222. Springer, 2017.\ndoi:10.1007/978-3-319-59776-8 17.\n[99] R. Wunderling.\nParalleler und objektorientierter Simplex-Algorithmus.\nDissertation,\nTechnische Universit¨at Berlin, 1996.\n[100] L. Xu, C. D’Ambrosio, L. Liberti, and S. H. Vanier.\nCutting planes for signomial\nprogramming, 2022.\nAuthor Affiliations\nSuresh Bolusani\nZuse Institute Berlin, Department AIS2T, Takustr. 7, 14195 Berlin, Germany\nE-mail: bolusani@zib.de\nORCID: 0000-0002-5735-3443\nMathieu Besan¸con\nUniversit´e Grenoble Alpes, Inria, LIG, 38000 Grenoble, France, and\nZuse Institute Berlin, Department AIS2T, Takustr. 7, 14195 Berlin, Germany\nE-mail: besancon@zib.de\nORCID: 0000-0002-6284-3033\nKsenia Bestuzheva\nZuse Institute Berlin, Department AIS2T, Takustr. 7, 14195 Berlin, Germany\nE-mail: bestuzheva@zib.de\nORCID: 0000-0002-7018-7099\nAntonia Chmiela\nZuse Institute Berlin, Department AIS2T, Takustr. 7, 14195 Berlin, Germany\nE-mail: chmiela@zib.de\nORCID: 0000-0002-4809-2958\nJo˜ao Dion´ısio\nCMUP and Department of Computer Science, Faculty of Sciences, University of Porto, R Campo\nAlegre, 4169–007 Porto, Portugal\nE-mail: joao.goncalves.dionisio@gmail.com\nORCID: 0009-0005-5160-0203\nTim Donkiewicz\nRWTH Aachen University, Lehrstuhl f¨ur Operations Research, Kackertstr. 7, 52072 Aachen,\nGermany\nE-mail: tim.donkiewicz@rwth-aachen.de\nORCID: 0000-0002-5721-3563\nJasper van Doornmalen\nEindhoven University of Technology, Department of Mathematics and Computer Science, P.O.\nBox 513, 5600 MB Eindhoven, The Netherlands\nE-mail: m.j.v.doornmalen@tue.nl\nORCID: 0000-0002-2494-0705\n33\nLeon Eifler\nZuse Institute Berlin, Department AIS2T, Takustr. 7, 14195 Berlin, Germany\nE-mail: eifler@zib.de\nORCID: 0000-0003-0245-9344\nOliver Gaul\nRWTH Aachen University, Lehrstuhl f¨ur Operations Research, Kackertstr. 7, 52072 Aachen,\nGermany\nE-mail: oliver.gaul@rwth-aachen.de\nORCID: 0000-0002-2131-1911\nMohammed Ghannam\nZuse Institute Berlin, Department AIS2T, Takustr. 7, 14195 Berlin, Germany\nE-mail: ghannam@zib.de\nORCID: 0000-0001-9422-7916\nAmbros Gleixner\nZuse Institute Berlin, Department AIS2T, Takustr. 7, 14195 Berlin, Germany\nE-mail: gleixner@zib.de\nORCID: 0000-0003-0391-5903\nChristoph Graczyk\nZuse Institute Berlin, Department AIS2T, Takustr. 7, 14195 Berlin, Germany\nE-mail: graczyk@zib.de\nORCID: 0000-0001-8990-9912\nKatrin Halbig\nFriedrich-Alexander Universit¨at Erlangen-N¨urnberg, Department of Data Science, Cauerstr. 11,\n91058 Erlangen, Germany\nE-mail: katrin.halbig@fau.de\nORCID: 0000-0002-8730-3447\nIvo Hedtke\nSchenker AG, Global Data & AI, Kruppstr. 4, 45128 Essen, Germany\nE-mail: ivo.hedtke@dbschenker.com\nORCID: 0000-0003-0335-7825\nAlexander Hoen\nZuse Institute Berlin, Department AIS2T, Takustr. 7, 14195 Berlin, Germany\nE-mail: hoen@zib.de\nORCID: 0000-0003-1065-1651\nChristopher Hojny\nEindhoven University of Technology, Department of Mathematics and Computer Science, P.O.\nBox 513, 5600 MB Eindhoven, The Netherlands\nE-mail: c.hojny@tue.nl\nORCID: 0000-0002-5324-8996\nRolf van der Hulst\nUniversity of Twente, Department of Discrete Mathematics and Mathematical Programming,\nP.O. Box 217, 7500 AE Enschede, The Netherlands\nE-mail: r.p.vanderhulst@utwente.nl\nORCID: 0000-0002-5941-3016\nDominik Kamp\nUniversity of Bayreuth, Chair of Economathematics, Universitaetsstr. 30, 95440 Bayreuth,\nGermany\n34\nE-mail: dominik.kamp@uni-bayreuth.de\nORCID: 0009-0005-5577-9992\nThorsten Koch\nTechnische Universit¨at Berlin, Chair of Software and Algorithms for Discrete Optimization,\nStraße des 17. Juni 135, 10623 Berlin, Germany, and\nZuse Institute Berlin, Department A2IM, Takustr. 7, 14195 Berlin, Germany\nE-mail: koch@zib.de\nORCID: 0000-0002-1967-0077\nKevin Kofler\nDAGOPT Optimization Technologies GmbH\nE-mail: kofler@dagopt.com\nJurgen Lentz\nRWTH Aachen University, Lehrstuhl f¨ur Operations Research, Kackertstr. 7, 52072 Aachen,\nGermany\nE-mail: jurgen.lentz@rwth-aachen.de\nORCID: 0009-0000-0531-412X\nJulian Manns\nZuse Institute Berlin, Department AIS2T, Takustr. 7, 14195 Berlin, Germany\nE-mail: manns@zib.de\nGioni Mexi\nZuse Institute Berlin, Department AIS2T, Takustr. 7, 14195 Berlin, Germany\nE-mail: mexi@zib.de\nORCID: 0000-0003-0964-9802\nErik M¨uhmer\nRWTH Aachen University, Lehrstuhl f¨ur Operations Research, Kackertstr. 7, 52072 Aachen,\nGermany\nE-mail: erik.muehmer@rwth-aachen.de\nORCID: 0000-0003-1114-3800\nMarc E. Pfetsch\nTechnische Universit¨at Darmstadt, Fachbereich Mathematik, Dolivostr. 15, 64293 Darmstadt,\nGermany\nE-mail: pfetsch@mathematik.tu-darmstadt.de\nORCID: 0000-0002-0947-7193\nFranziska Schl¨osser\nFair Isaac Germany GmbH, Takustr. 7, 14195 Berlin, Germany\nE-mail: franziskaschloesser@fico.com\nFelipe Serrano\nCOPT GmbH, Berlin, Germany\nE-mail: serrano@copt.de\nORCID: 0000-0002-7892-3951\nYuji Shinano\nZuse Institute Berlin, Department A2IM, Takustr. 7, 14195 Berlin, Germany\nE-mail: shinano@zib.de\nORCID: 0000-0002-2902-882X\nMark Turner\nZuse Institute Berlin, Department A2IM, Takustr. 7, 14195 Berlin, Germany\n35\nE-mail: turner@zib.de\nORCID: 0000-0001-7270-1496\nStefan Vigerske\nGAMS Software GmbH, c/o Zuse Institute Berlin, Department AIS2T, Takustr. 7, 14195 Berlin,\nGermany\nE-mail: svigerske@gams.com\nORCID: 0009-0001-2262-0601\nDieter Weninger\nFriedrich-Alexander Universit¨at Erlangen-N¨urnberg, Department of Mathematics, Cauerstr. 11,\n91058 Erlangen, Germany\nE-mail: dieter.weninger@fau.de\nORCID: 0000-0002-1333-8591\nLiding Xu\n´Ecole polytechnique, LIX CNRR, Rue Honor´e d’Estienne d’Orves. 1, 9120 Palaiseau, France\nE-mail: lidingxu.ac@gmail.com\nORCID: 0000-0002-0286-1109\n36\n"
}