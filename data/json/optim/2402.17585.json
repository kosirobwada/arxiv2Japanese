{
    "optim": "Communication-Constrained STL Task Decomposition through\nConvex Optimization\nGregorio Marchesini, Siyuan Liu, Lars Lindemann and Dimos V. Dimarogonas\nAbstract— In this work, we propose a method to decompose\nsignal temporal logic (STL) tasks for multi-agent systems\nsubject to constraints imposed by the communication graph.\nSpecifically, we propose to decompose tasks defined over multi-\nple agents which require multi-hop communication, by a set of\nsub-tasks defined over the states of agents with 1-hop distance\nover the communication graph. To this end, we parameterize\nthe predicates of the tasks to be decomposed as suitable hyper-\nrectangles. Then, we show that by solving a constrained convex\noptimization, optimal parameters maximising the volume of the\npredicate’s super-level sets can be computed for the decomposed\ntasks. In addition, we provide a formal definition of conflicting\nconjunctions of tasks for the considered STL fragment and\na formal procedure to exclude such conjunctions from the\nsolution set of possible decompositions. The proposed approach\nis demonstrated through simulations.\nI. INTRODUCTION\nTemporal logics have recently received increasing atten-\ntion as they allow for expressing high-level collaborative\ntasks among agents in a multi-agent system (MAS). Among\nthe different temporal logics, signal temporal logic (STL) is\nan expressive language that has been successfully applied\nfor both high-level planning [1], [2] and low-level feedback\ncontrol [3], [4] of multi-agent systems. The possibility of\nexpressing both the temporal and spatial behavior of MASs\nwithout leveraging abstraction-based techniques makes STL\nparticularly appealing for real-time control and planning by\navoiding the curse of dimensionality.\nAt the current state of the art, three main low-level control\napproaches have been developed for the satisfaction of high-\nlevel STL tasks for MASs: prescribed performance control\n[5], [6], mixed-integer linear programs (MILP) [7], [8],\n[9], [10], and time-varying control barrier functions (CBF)\n[3], [4]. In all the aforementioned works, it is taken for\ngranted that the connectivity of the communication networks\nis ensured and always compatible with the task dependency\ngraphs of MASs. Indeed, it is commonly assumed that each\nagent has either global state information about the system,\nor that agents involved in the same tasks can share state\ninformation by leveraging 1-hop communication. Neverthe-\nless, this assumption is commonly violated in many real-\nThis work was supported in part by the Horizon Europe EIC project\nSymAware (101070802), the ERC LEAFHOUND Project, the Swedish\nResearch Council (VR), Digital Futures, and the Knut and Alice Wallenberg\n(KAW) Foundation.\nGregorio\nMarchesini,\nSiyuan\nLiu,\nand\nDimos\nV.\nDimarogonas\nare\nwith\nthe\nDivision\nof\nDecision\nand\nControl\nSystems,\nKTH\nRoyal\nInstitute\nof\nTechnology,\nStockholm,\nSweden.\nE-mail:\n{gremar,siyliu,dimos}@kth.se. Lars Lindemann is with the\nThomas Lord Department of Computer Science, University of Southern\nCalifornia, Los Angeles, CA, USA. E-mail: {llindema}@usc.ed.\nworld scenarios and fully decentralised control can not be\nachieved by the previous low-level control approaches when\nthis assumption is not met. In this work, we propose a\nfirst step toward relaxing such assumption by decomposing\ntasks defined over multiple agents subject to multi-hop\ncommunication into conjunctions of sub-tasks that can be\nachieved by leveraging only 1-hop communication over the\ncommunication graph.\nThe results in [11] established a paradigm to decompose\nSTL tasks defined over MASs into a set of tasks that can\nbe independently satisfied by distinct sub-clusters of agents.\nHowever, the mismatch between the communication graph\nand task dependency graph of the MASs is not considered\nin the decomposition process, while each sub-cluster is con-\nsidered to be fully connected. Similarly, [12] and [13] employ\nMILP to achieve the same type of decomposition as in [11],\nbut the underlying communication topology of the multi-\nagent system is again not considered, and thus decentralised\ncontrol cannot be leveraged in the absence of fully connected\nsub-clusters. In [9], communication constraints are consid-\nered in the motion planning approach of MASs. A MILP is\nsolved to compute a valid state trajectory for the MAS that\nsatisfies a global STL task, while maintaining an optimized\ninter-agent communication quality of service. Nevertheless,\nperfect inter-agent communication is still assumed for agents\nunder the same collaborative tasks.\nThe main contributions of this work are twofold. First, we\npropose a communication-constrained decomposition for a\nfragment of STL tasks defined over the absolute and relative\nstate of the agents in the MAS. Namely, we exploit the\ncommunication graph of the MAS to decompose tasks whose\npredicate functions depend on the agents which require\nmulti-hop communication into a conjunction of sub-tasks\ndefined over the agents that have one 1-hop communication.\nEach newly introduced sub-task is defined over a parametric\npredicate function depending on the relative state of couples\nof agents in the system linked by the communication graph.\nBy leveraging convex optimization tools, optimal parameters\nfor each sub-task are then computed such that the volume of\nthe super-level set of the predicate functions is maximised\n[11]. The decomposed tasks allow for a fully decentralised\ncontrol approach for MASs. Second, we formally derive a set\nof conditions that can lead to un-satisfiable conjunctions of\ntasks in the considered STL fragments. We also provide a set\nof convex constraints to be included in the original convex\noptimization such that un-satisfiable conjunctions of tasks are\nexcluded from the solution set of our task decomposition.\nThe paper is organized as follows. Section II presents pre-\narXiv:2402.17585v1  [eess.SY]  27 Feb 2024\nliminaries and Section III introduces the problem definition.\nSection IV proposes our main task decomposition result. In\nSection V, we provide a formal definition of conflicting con-\njunctions of tasks and then propose a strategy to avoid such\nconflicts. Simulation results are provided in Section VI to\ndemonstrate our decomposition approach, while concluding\nremarks are given in Section VII.\nNotation: Bold letters indicate vectors while capital let-\nters indicate matrices. Vectors are considered to be column\nvectors and the notation x[k] indicates the k-th element of\nx. We define the minimum of a vector a ∈ Rn element-\nwise as\n⋆\nmin(a) := mink=1,...n{a[k]}. The notation |A|\ndenotes the cardinality of the set A, the symbol ⊕ indicates\nthe Minkowski sum, the notation Qk\ni=1 Ai represents the\nCartesian product of the sets Ai and −A = {x|x = −v ∀v ∈\nA}. We denote the power set of A as P(A). The identity\nmatrix of dimension n is denoted as In. The set R+ denotes\nthe non-negative real numbers.\nII. PRELIMINARIES\nLet V = {1, . . . N} be the set of indices assigned to\neach agent in a multi-agent system. We write the input-affine\nnonlinear dynamics for each agent i ∈ V as\n˙xi = fi(xi) + gi(xi)ui\n(1)\nwhere xi ∈ Xi ⊂ Rni is the state of the i-th agent and\nui ∈ Ui ⊂ Rmi is the associated bounded control input. We\nassume, without loss of generality, that ni = n, ∀i ∈ V. Let\nfi : Rn → Rn and gi : Rn → Rn×mi be locally Lipschitz\ncontinuous functions of the agent state. We denote the full\nstate of the system as x := [xT\n1 , xT\n2 , . . . xT\nN]T . Given a\ncontrol input ui : [t0, t1] → Ui, we define the state trajectory\nxi : [t0, t1] → Xi for agent i ∈ V if xi(t) satisfies (1)\nfor all t ∈ [t0, t1]. We Also define the relative state vector\neij := xj − xi for i, j ∈ V.\nA. Signal Temporal Logic\nSTL is a predicate logic applied to formally define spa-\ntial and temporal behaviours of real-valued continuous-time\nsignals [14]. The atomic elements of STL are Boolean\npredicates µ : R → {⊤, ⊥} defined as µ :=\n\b ⊤ if h(x)≥0\n⊥ if h(x)<0,\nwhere h(x) : Rn → R is a scalar valued predicate function.\nThe value of h can generally depend upon the state of all the\nagents of the multi-agent system or a subset of the former.\nThe STL grammar is recursively defined as:\nϕ ::= ⊤|µ|¬ϕ|ϕ1 ∧ ϕ2|F[a,b]ϕ|G[a,b]ϕ|ϕ1U[a,b]ϕ2\nwhere F[a,b], G[a,b] and U[a,b] are the temporal eventually,\nalways and until operators over the time interval [a, b] ⊂ R+.\nWe indicate that a state trajectory x(t) satisfies task ϕ at\ntime t as x(t) |= ϕ. The classical STL semantics define\nthe conditions such that x(t) |= ϕ [14]. In the current\nwork, we leverage the robust quantitative STL semantics:\nρµ(x, t) = h(x(t)), ρ¬ϕ(x, t) = −ρϕ(x, t), ρϕ1∧ϕ2(x, t) =\nmin\n\u0000ρϕ1(x, t), ρϕ2(x, t)\n\u0001\n, ρϕ1U[a,b]ϕ2(x, t)\n=\nmaxt1∈[t+a,t+b] min\n\u0000ρϕ2 (x, t1) , mint2∈[t,t1] ρϕ1 (x, t2)\n\u0001\n,\nρF[a,b]ϕ(x, t) = maxt1∈[t+a,t+b] ρϕ (x, t1) , ρG[a,b]ϕ(x, t) =\nmint1∈[t+a,t+b] ρϕ (x, t1) ,\nand\nwe\nrecall\nthe\nrelations\nρϕ(x, 0) > 0 ⇒ x(t) |= ϕ [15], [16], [17]. In this work,\nwe focus on STL tasks defined over predicate functions\nthat depend on the state xi of a single agent and/or on the\nrelative state vector eij between two agents. Namely, we\nmake use of the following STL fragment:\nϕi := F[a,b]µi|G[a,b]µi|ϕ1\ni ∧ ϕ2\ni ,\n(2a)\nϕij := F[a,b]µij|G[a,b]µij|ϕ1\nij ∧ ϕ2\nij,\n(2b)\nwhere µi :=\n\b ⊤ if hi(xi)≥0\n⊥ if hi(xi)<0, , µij :=\n\b ⊤ if hij(eij)≥0\n⊥ if hij(eij)<0, with\npredicate functions hi(xi) and hij(eij). We refer to tasks as\nper (2a) as independent and tasks as per (2b) as collaborative.\nAdditionally, we identify the respective super-level sets as\nBi = {xi ∈ Xi|hi(xi) ≥ 0};\nBij = {eij ∈ Xi ⊕ (−Xj)|hij(eij) ≥ 0}.\n(3)\nB. Communication and Task Graphs\nWe define an undirected graph over the set of agents V\nas G(V, E) ∈ Γ, where E ⊆ V × V is the set of undirected\nedges of G and Γ is the set of undirected graphs over the\nnodes V. We define the set of neighbours of vertex i as\nN(i) = {j|(i, j) ∈ E ∧ i ̸= j} and the extended neighbour\nset as ¯\nN(i) := N ∪ {i} such that self-loops are considered.\nLet the graph-valued function add(·, ·) : Γ × V × V → Γ\nbe such that G′(E′, V) = add(G, Q) with E′ = E ∪ Q for a\ngiven set of edges Q ⊂ V ×V. Similarly we define del(·, ·) :\nΓ × V × V → Γ such that G′(E′, V) = del(G, Q) and E′ =\nE \\ Q. Let the vector πj\ni ∈ Vl represent a directed path of\nlength l defined as a vector of non-repeated indices in V\nsuch that πj\ni [k] ∈ V ∀k = 1, . . . l , πj\ni [r] ̸= πj\ni [s] ∀s ̸= r ,\n(πj\ni [r], πj\ni [r + 1]) ∈ E and (πj\ni [1], πj\ni [l]) = (i, j). Let ω ∈\nVl represent a directed closed cycle path, such that ω is a\ndirected path and ω[1] = ω[l]. Let ϵ : Vl → P(E) be a set-\nvalued function such that ϵ(πj\ni ) = {(πj\ni [k], πj\ni [k + 1])|k =\n1, . . . l − 1}. We establish the relations\neij =\nX\n(r,s)∈ϵ(πj\ni )\ners,\n0 =\nX\n(r,s)∈ϵ(ω)\ners.\n(4)\nWe further make a distinction between two types of graphs\nthat refer to a multi-agent system. Namely, we define the\ncommunication graph Gc(V, Ec) ∈ Γ such that (i, j) ∈ Ec ⊂\nV × V if i and j are able to communicate their respective\nstate to each other. It is assumed that each agent is always\nable to communicate with itself. We also define the task\ngraph Gψ(V, Eψ) ∈ Γ such that (i, j) ∈ Eψ if there exists\na collaborative task ϕij as per (2b) between agent i and j.\nIndependent tasks ϕi as per (2a) induce self-loops in the\ntask graph (see in Fig. 1). We repeatedly make use of the\nsubscript c and ψ to differentiate among properties of the\ncommunication and task graph, respectively. For instance,\nNc(i) and Nψ(i) indicate the neighbour set of agent i in\nthe communication graph and task graph, respectively. We\ndefine ψ as the global task assigned to the MAS as\nψ :=\nN\n^\ni=1\n\nϕi ∧\n^\nj∈Nψ(i)\nϕij\n\n .\n(5)\nFig. 1: Simple example of communication (left) and task\ngraph (right) for a multi-agent system with 6 agents. The task\nand communication graph are mismatching in their case.\nGlobal tasks according to (5) are particularly suitable for\ndefining, e.g. time-varying relative formations. We propose\nan example to clarify the notation introduced so far.\nExample 1: Consider the communication and task graphs\nin Fig 1. Agents 2 and 5 have an independent task ϕ2, ϕ5\nrespectively, while ϕ12, ϕ13, ϕ14, ϕ16, ϕ56, ϕ26 are collabora-\ntive tasks. The path π3\n1 = [1, 2, 3] connects agent 1 to 3\nwith length l = 3 and ϵ(π3\n1) = {(1, 2), (2, 3)}. Likewise,\nπ2\n6 = [6, 1, 2] and ϵ(π2\n6) = {(6, 1), (1, 2)}. Agents 1, 2, 6\nform a cycle of tasks ω = [1, 2, 6, 1] in Gψ.\nWe conclude this section by stating the three main assump-\ntions that hold throughout the work:\nAssumption 1: (Connectivity) The communication graph\nGc is a time-invariant connected graph.\nAssumption 2: (Concavity) The predicate functions hij\nand hi are concave functions of eij and xi respectively.\nAssumption 3: (Task symmetry) For each STL task ϕij\nin (2b), we have that ϕij = ϕji ∀(i, j) ∈ Eψ.\nThe first assumption is required to obtain a decomposition\nand ensure that such decomposition remains valid over time.\nWe leave the case of time-varying Gc as future work. The\nsecond assumption is required to maintain the super-level\nsets Bij in (3) convex. Note that the same assumptions were\nconsidered in [11] for a similar task decomposition. The last\nAssumption 3 is not restrictive since the Gψ is undirected.\nIII. PROBLEM FORMULATION\nPrevious works in STL control often assume that Gc\nis fully connected or that ψ can be decomposed into a\nconjunction of tasks defined over the state of fully connected\nsub-clusters of agents in Gc. In the current work, we seek\nto drop these assumptions. Indeed, given the structure of\nψ as a conjunction of collaborative tasks among couples\nof agents or independent tasks, then the satisfaction of ψ\ncan be achieved by designing a fully decentralised low-level\ncontroller for each agent i, requiring only state information\nfrom the 1-hop neighbours in Nc(i) when Nψ(i) ⊆ Nc(i)\n[4]. However, a decentralised control approach that can\nguarantee the satisfaction of ψ when Nψ(i) ̸⊆ Nc(i) is not\navailable in the literature. Thus, we wish to exploit Gc to\nconstruct a new task ¯ψ in the form of (5) and a new graph\nG ¯\nψ such that N ¯\nψ(i) ⊆ Nc(i) and (x, t) |= ¯ψ ⇒ (x, t) |= ψ.\nWith this goal, we decompose the original tasks ϕij, with\nFig. 2: Example of decomposition according to (7).\n(i, j) ∈ Eψ \\ Ec, over the relative states of a path of agents\nπj\ni over Gc. We formalise the problem as follows:\nProblem 1: Consider the multi-agent system with agents\nin V, communication graph Gc and task graph Gψ such that\nψ is according to (5) and Eψ \\ Ec ̸= ∅. Then, define a new\nglobal task ¯ψ in the form\n¯ψ :=\nN\n^\ni=1\n\nϕi ∧\n^\nj∈Nψ(i)∩Nc(i)\nϕij ∧\n^\nj∈Nψ(i)\\Nc(i)\nϕπj\ni\n\n ,\n(6)\nwith the new task graph being G ¯\nψ, such that ∀(i, j) ∈ Eψ \\Ec\nϕπj\ni :=\n^\n(r,s)∈ϵ(πj\ni )\n¯ϕ\nπj\ni\nrs,\n(7)\nwhere πj\ni are paths in Gc such that ϵ(πj\ni ) ⊂ Ec and ¯ϕ\nπj\ni\nrs\nare tasks of type (2b) to be appropriately defined such that\nx(t) |= ¯ψ implies x(t) |= ψ.\nExample 2: Consider Fig 2. Agents 1 and 4 share a\ncollaborative task ϕ14, which cannot be directly satisfied\nas the two agents are not communicating (indicated by a\ndashed line). The task ϕ14 is then replaced by the task\nϕπ4\n1 = ¯ϕπ4\n1\n12 ∧ ¯ϕπ4\n1\n23 ∧ ¯ϕπ4\n1\n34 where π4\n1 = [1, 2, 3, 4].\nIn the next sections, we will develop on how the tasks ¯ϕ\nπj\ni\nrs\nare defined according to Gc and the temporal properties of\nthe collaborative tasks ϕij with (i, j) ∈ Eψ \\ Ec.\nIV. TASK DECOMPOSITION\nWe outline the task decomposition approach applied to\nobtain a single task ϕπj\ni , according to (7), from a given\ncollaborative task ϕij = T[a,b]µij with T ∈ {G, F} as\ndefined in (2b) (see Fig. 2). In the case where ϕij contains\nconjunctions of tasks as ϕij = V\nk ϕk\nij, the method developed\nin this section is applied for each ϕk\nij, leading to ϕij being\ndecomposed as ϕπj\ni = V\nk(ϕπj\ni )k. Each (ϕπj\ni )k is obtained\nwith the same approach applied in the single task case\npresented in this section. We further elaborate on this point\nin Remark 2.\nA. Path decomposition of STL tasks\nConstructing task ϕπj\ni requires two steps: 1) find a path\nπj\ni from agents i to j through Gc, 2) find a family of tasks\n¯ϕ\nπj\ni\nrs that can be applied to construct ϕπj\ni as per (7) such\nthat x(t) |= ϕπj\ni\n⇒ x(t) |= ϕij. The solution to step\n1 is readily available from the literature as there exists a\nplethora of algorithms for finding a path from node i to\nnode j in a connected graph [18]. We highlight that finding\nthe shortest path connecting two nodes is not a requirement\nfor our work and thus we select the well-known Dijkstra\nalgorithm. On the other hand, for the solution of step 2,\nwe leverage axis-aligned n-dimensional hyper-rectangles as\nsuitable predicate functions for the tasks ¯ϕ\nπj\ni\nrs [19], [20]. The\nfollowing definitions and properties of hyper-rectangles are\nprovided:\nDefinition 1: ([19, Ch .1.1][20, Def 3.6]) Given ν ∈ Rn\nsuch that ν[k] ∈ R+\n∀k ∈ 1, . . . n and p ∈ Rn, an axis-\naligned hyper-rectangle H(p, ν) is defined as H(p, ν) =\nQn\nk=1[p[k]−ν[k]/2, p[k]+ν[k]/2]. Equivalently, H(p, ν) =\n{ζ\n∈ Rn|A(ζ − p) − b(ν) ≥ 0} such that b(ν) =\n[νT /2, −νT /2] and A = [In, −In]T .\nProposition 1: ([19, Ch. 1.1]) Any point ζ ∈ H(p, ν)\nis a convex combination of the set of vertices P(p, ν) :=\n{v ∈ Rn|v[s] = p[s] + ν[s]/2 or v[s] = p[s] − ν[s]/2 ∀s =\n1, . . . n}, where |P(p, ν)| = 2n, such that ζ = P2n\ni=1 λivi,\nwith P2n\ni\nλi = 1, 0 ≥ λi ≥ 1 and vi ∈ P(p, ν).\nProposition 2: ([20])\nLet\ntwo\naxis\naligned\nhyper-\nrectangles H1(p1, ν1), H2(p2, ν2), then the Minkowski sum\nH3(p3, ν3) = H1(p1, ν1) ⊕ H2(p2, ν2) is an axis aligned\nhyper-rectangle such that p3 = p1 + p2 and ν3 = ν1 + ν2.\nProposition 3: ([19]) Consider a concave scalar-valued\nfunction g : Rn → R and hyper-rectangle H(p, ν). If\ng(vi) ≥ 0 ∀vi ∈ P(p, ν) then g(ζ) ≥ 0 ∀ζ ∈ H(p, ν).\nIf for each task ¯ϕ\nπj\ni\nrs with (r, s) ∈ ϵ(πj\ni ) we define a centre\np\nπj\ni\nrs and a dimension vector ν\nπj\ni\nrs as parameters, we can\nemploy the following family of concave predicate functions\nwith respective predicate and super-level set:\n¯h\nπj\ni\nrs(ers, η\nπj\ni\nrs ) :=\n⋆\nmin(A(ers − p\nπj\ni\nrs) − b(ν\nπj\ni\nrs )) ≥ 0, (8a)\n¯B\nπj\ni\nrs (η\nπj\ni\nrs ) := {ers ∈ Xr ⊕ (−Xs)|¯h\nπj\ni\nrs(ers, η\nπj\ni\nrs ) ≥ 0},\n(8b)\n¯µ\nπj\ni\nrs(η\nπj\ni\nrs ) :=\n\n\n\n⊤\nif\n¯h\nπj\ni\nrs(ers, η\nπj\ni\nrs ) ≥ 0\n⊥\nif\n¯h\nπj\ni\nrs(ers, η\nπj\ni\nrs ) < 0,\n(8c)\nwhere η\nπj\ni\nrs := [(p\nπj\ni\nrs)T , (ν\nπj\ni\nrs )T ]T are free parameters. We\nrecall that\n⋆\nmin is the element-wise minimum and\n⋆\nmin(A(ζ−\np) − b) ≥ 0 ⇒ A(ζ − p) − b ≥ 0 for a given ζ. The vector\nη\nπj\ni\nrs is computed as a result of the convex program defined\nin Theorem 1. The parametric set ¯B\nπj\ni\nrs in (8b) is a convex\nhyper-rectangle by Def. 1 with volume given by Qn\ns=1 ν\nπj\ni\nrs [s]\n[16]. Hyper-rectangles are particularly suitable for the task\ndecomposition due to their efficient vertex representation and\nMinkowski computation in Proposition 2 [16, Sec. 3.6]. In\nprinciple, any zonotope can be used for the decomposition\npresented as we clarify in Remark 2. We can now state our\nfirst decomposition result:\nLemma 1: Consider a task ϕij = T[a,b]µij with T ∈\n{G, F} according to (2b), the corresponding predicate func-\ntion hij satisfying Assumption 2 and Bij according to (3).\nFurther consider a path πj\ni through the communication graph\nGc and ϕπj\ni = V\n(r,s)∈ϵ(πj\ni ) ¯ϕ\nπj\ni\nrs such that each ¯ϕ\nπj\ni\nrs is defined\nas\n¯ϕ\nπj\ni\nrs :=\n\n\n\nF[a∗,b∗]¯µ\nπj\ni\nrs if T = F\n(9a)\nG[a∗,b∗]¯µ\nπj\ni\nrs if T = G, ,\n(9b)\nwith [a∗, b∗] defined as\n[a∗, b∗] :=\n( \u0002¯t, ¯t\n\u0003\nwith ¯t ∈ [a, b] if T = F\n(10a)\n\u0002\na, b\n\u0003\nif T = G,\n(10b)\nwhere\nthe\npredicate\n¯µ\nπj\ni\nrs(η\nπj\ni\nrs ),\npredicate\nfunction\n¯h\nπj\ni\nrs(ers, η\nπj\ni\nrs ) and super-level set\n¯B\nπj\ni\nrs (η\nπj\ni\nrs ) are as per\n(8). If ¯ϕ\nπj\ni\nrs are defined according to (9)-(10) and\nM\n(r,s)∈ϵ(πj\ni )\n¯B\nπj\ni\nrs (η\nπj\ni\nrs ) ⊆ Bij;\n(11)\nthen x(t) |= ϕπj\ni ⇒ x(t) |= ϕij.\nProof: We prove the lemma for ϕij := F[a,b]µij while\nthe case of ϕij := G[a,b]µij follows a similar procedure.\nWe omit the dependency of ¯h\nπj\ni\nrs, B\nπj\ni\nrs from η\nπj\ni\nrs to reduce\nthe burden of notation. Given the path πj\ni over Gc we define\nϕπj\ni = V\n(r,s)∈ϵ(πj\ni ) ¯ϕ\nπj\ni\nrs = V\n(r,s)∈ϵ(πj\ni ) F[¯t,¯t]¯µ\nπj\ni\nrs according to\n(9)-(10), where [¯t, ¯t] ⊆ [a, b]. It is known that x(t) |= ϕπj\ni ⇒\nρϕπj\ni (x, 0) = min(r,s)∈ϵ(πj\ni ){ρ ¯ϕ\nπj\ni\nrs (x, 0)} > 0. By defini-\ntion of robust semantics for the F operator we know that\nρ ¯ϕ\nπj\ni\nrs (x, 0) > 0 ⇒ ∃trs ∈ [¯t, ¯t] such that ¯h\nπj\ni\nrs(ers(trs)) >\n0 ∀(r, s) ∈ ϵ(πj\ni ). Since the interval [¯t, ¯t] only contains\n¯t, then trs = ¯t ∀(r, s) ∈ ϵ(πj\ni ). Hence ρ ¯ϕ\nπj\ni\nrs (x, 0) >\n0 ⇒ ¯h\nπj\ni\nrs(ers(¯t)) > 0 ⇒ ers(¯t) ∈\n(8b)\n¯B\nπj\ni\nrs ∀(r, s) ∈ ϵ(πj\ni ).\nFrom (4) and (11) we have eij(¯t) =\n(4)\nP\n(r,s)∈ϵ(πj\ni ) ers(¯t) ∈\nL\n(r,s)∈ϵ(πj\ni ) ¯B\nπj\ni\nrs ⊆\n(11) Bij ⇒ eij(¯t) ∈ Bij] ⇒ hij(eij(¯t)) >\n0. We thus arrived at the conclusion since ¯t ∈ [a, b] and the\nrobust semantics for the F operator we have ρϕij(x, 0) =\nmaxt∈[a,b](hij(eij(t))) > 0 ⇒ x(t) |= ϕij.\nWe highlight that L\n(r,s)∈ϵ(πj\ni ) ¯B\nπj\ni\nrs is an axis-aligned hyper-\nrectangles according to Prop. 2. Moreover, from Assumption\n2, each hij is concave, such that satisfying (11) consists\nin verifying the 2n convex relations −hij(v) ≤ 0 over the\nvertices v ∈ P(pπj\ni , νπj\ni ), where pπj\ni = P\n(r,s)∈ϵ(πj\ni ) p\nπj\ni\nrs\nand νπj\ni = P\n(r,s)∈ϵ(πj\ni ) ν\nπj\ni\nrs as per Prop. 2.\nB. Computing optimal parameters\nIn Lemma 1 we showed that (9), (10) and (11) imply\nx(t) |= ϕπj\ni\n⇒ x(t) |= ϕij. In Thm. 1, we present a\nprocedure to compute the parameters η\nπj\ni\nrs for each task ¯ϕ\nπj\ni\nrs\nsuch that the (9), (10) and (11) are satisfied and the volumes\nof the super-level set ¯B\nπj\ni\nrs are maximized. Namely, given\na single hyper-rectangle ¯B\nπj\ni\nrs , it is possible to maximize\nits volume Qn\nk=1 ν\nπj\ni\nrs [k], by minimizing (Qn\nk=1 ν\nπj\ni\nrs [k])−1,\nwhich is a convex function since ν\nπj\ni\nrs [k] > 0 ∀k = 1, . . . n.\nFor convenience, we introduce the set Θπj\ni := {η\nπj\ni\nrs |∀(r, s) ∈\nϵ(πj\ni )} which gathers all the parameter along a path πj\ni\napplied for the decomposition of a given task ϕij and Θ =\nS\n(i,j)∈Eψ\\Ec Θπj\ni is then the set that of all the parameters\napplied for the decomposition. We are now ready to present\nour second result.\nTheorem 1: Consider a multi-agent system with agents\nin V and subject to a global task ψ according to (2). Further\nconsider the associated task and communication graphs Gc,\nGψ such that Eψ \\ Ec ̸= ∅ and Gc respects Assumption 1.\nFor all (i, j) ∈ Eψ \\ Ec consider the paths πj\ni in Gc and the\ncorresponding task ϕπj\ni satisfying the conditions in Lemma\n1. Define the following convex optimization problem\nmin\nη\nπj\ni\nrs ∈Θ\nX\n(i,j)∈Eψ\\Ec\nX\n(r,s)∈ϵ(πj\ni )\n\u0010 n\nY\nk=1\nν\nπj\ni\nrs [k]\n\u0011−1\n(12a)\nM\n(r,s)∈ϵ(πj\ni )\n¯B\nπj\ni\nrs (η\nπj\ni\nrs ) ⊆ Bij ∀(i, j) ∈ Eψ \\ Ec,\n(12b)\nAssuming feasibility of (12) and that there exists x(t) such\nthat x(t) |= ¯ψ with ¯ψ according to (6), then x(t) |= ψ.\nProof:\nGiven that a solution to (12) exists, then\nthe satisfaction of the constraints set (12b) implies that\ncondition (11) is satisfied for all (i, j) ∈ Eψ \\ Ec. The\nconditions from Lemma 1 are then satisfied for all ϕπj\ni\nwith (i, j) ∈ Eψ \\ Ec. We now analyse the satisfaction of ψ\nand ¯ψ through the definition of the robust semantics such\nthat ρψ = min{min\ni∈V {ρϕi}, min(i,j)∈Eψ{ρϕij}} and ρ ¯\nψ =\nmin{min\ni∈V {ρϕi}, min(i,j)∈Eψ∩Ec{ρϕij} min(i,j)∈Eψ\\Ec{ρϕπj\ni }};\nwhere we have omitted the dependency from (x, 0).\nAssuming\nthat\nx(t)\n|=\n¯ψ,\nthen\nρϕij(x, 0)\n>\n0 ∀(i, j) ∈ Eψ ∩ Ec and ρϕi(x, 0) > 0. Furthermore,\nwe know from Lemma 1 that ρϕπj\ni (x, 0)\n>\n0\n⇒\nρϕij(x, 0)\n>\n0\n∀(i, j)\n∈\nEψ \\ Ec\nand eventually\nρϕij(x, 0) > 0 ∀(i, j) ∈ Eψ ⇒ x(t) |= ¯ψ ⇒ x(t) |= ψ.\nIf we define the set of edges involved in the decomposition\nof ψ as Q := S\n(i,j)∈Eψ\\Ec ϵ(πj\ni ) then we can write G ¯\nψ as\na function of Gψ as G ¯\nψ = add\n\u0000del(Gψ, Eψ \\ Ec), Q\n\u0001\n, which\ncorrespond to deleting all the edges in Gψ not corresponding\nto an edge in Gc, while we add all the edges from Gc that\nare introduced by the paths πj\ni during the decomposition.\nWe have thus deduced a procedure that solves Problem 1.\nRemark 1: Problem (12) handles cases in which ϕij has\nconjunctions. Indeed, if ϕij = ∧p\nk=1ϕk\nij for some p ≥ 1 then\nwe define a task (ϕπj\ni )k as per Lemma 1 and a constraint as\nper (12b) for each k = 1, . . . p to be introduced in (12).\nRemark 2: In principle, any type of zonotope can be\nemployed for the decomposition approach developed. How-\never, we remark that the cost of imposing constraint (12b)\nincreases with the number of vertices defining the Minkowski\nsum in the left-hand side of (12b).\nWe outline that although (12) might yield a solution, there is\nno guarantee that the tasks ϕπj\ni computed from (12) in Thm.\n1 can be satisfied in conjunction with each other or that\nthey can be satisfied in conjunction with the un-decomposed\nformulas ϕij ∀(i, j) ∈ Eψ ∩ Ec. In other words, the new task\n¯ψ obtained from the optimization problem presented in Thm.\n1 is not guaranteed to be satisfiable. We analyse this problem\nin the next section.\nV. DEALING WITH CONFLICTS\nA. Conflicting conjuncitons\nWe consider the following notion of conflicting conjunc-\ntion for formulas defined by the STL fragment (2):\nDefinition 2: (Conflicting conjunction) A conjunction of\nformulas V\nk ϕk\nij, where ϕk\nij is according to (2b), is a con-\nflicting conjunction if there does not exist a state trajectory\nx(t) for the multi-agent system such that x(t) |= V\nk ϕk\nij.\nIn this section, we first state the four types of conflicting\nconjunctions that we consider for fragment in (2) and we\nconjecture that these are the only 4 possible types. Second,\nwe provide sufficient conditions that can be enforced as\nconvex constraints in Theorem 1 such that the obtained ¯ψ\ndoes not suffer from conflicting conjunctions. We assume\nthat for the original global task ψ, none of these conflicts\narise, while they could arise due to the introduction of the\nnew formulas ϕπj\ni during the decomposition process outlined\nin Thm. 1. For ease of notation, in this section, we drop the\nnotation ¯ϕ\nπj\ni\nrs and we rewrite all the tasks ϕij in G ¯\nψ for a\nsingle edge (i, j) ∈ E ¯\nψ as\nϕij =\n^\nk∈Ig\nij\nϕk\nij ∧\n^\nk∈If\nij\nϕk\nij\n(13a)\nϕk\nij = G[ak,bk]µk\nij if k ∈ Ig\nij,\n(13b)\nϕk\nij = F[ak,bk]µk\nij\nif k ∈ If\nij.\n(13c)\nsuch that Iij := Ig\nij∪If\nij. Differently from (2b), we highlight\nthat after the decomposition each edge (i, j) ∈ E ¯\nψ can\ncontain parametric tasks according to (9) and un-decomposed\ntasks from ψ as per (2b) that are directly inherited by\n¯ψ. In order to differentiate between the formers and the\nlatters, we introduce the sets ¯F and F such that ϕk\nij ∈ ¯F\nif ϕk\nij is a task according to (9), while ϕk\nij ∈ F if ϕk\nij\nis defined according to (2b). For any task ϕk\nij in (13b)-\n(13c) we define the associated predicate function hk\nij(eij),\npredicate µk\nij(eij) :=\n\b ⊤\nif\nhk\nij(eij,ηij)≥0\n⊥\nif\nhk\nij(eij,ηij)<0, and super-level\nset Bk\nij = {eij|hk\nij(eij) ≥ 0}, which is a parametric hyper-\nrectangle if ϕk\nij ∈ ¯F as per (8b). We now present the four\ntypes of conflicting conjunctions we consider.\nFact 1: (Conflict of type 1) Consider two tasks ϕk\nij and\nϕq\nij defined over the edge (i, j) ∈ E ¯\nψ and such that k, q ∈ Ig\nij\nIf [aq, bq] ∩ [ak, bk] ̸= ∅ and Bk\nij ∩ Bq\nij = ∅ then ϕk\nij ∧ ϕq\nij is\na conflicting conjunction.\nProof:\nWe prove the fact by contradiction. Suppose\nthere exists x(t) such that x(t)\n|=\nϕq\nij ∧ ϕk\nij. Then\nρϕq\nij∧ϕk\nij(x, 0)\n=\nmin{ρϕq\nij(x, 0), ρϕk\nij(x, 0)}\n>\n0\n⇒\nρϕq\nij(x, 0) > 0 ∧ ρϕk\nij(x, 0) > 0. Recalling the definition of\nrobust semantics for the G operator we have hq\nij(eij(t)) >\n0 ∀t ∈ [aq, bq] ⇒ eij(t) ∈ Bq\nij\n∀t ∈ [aq, bq] and\nhk\nij(eij(t)) > 0 ∀t ∈ [ak, bk] ⇒ eij(t) ∈ Bk\nij ∀t ∈ [ak, bk].\nSince [ak, bk] ∩ [aq, bq] ̸= ∅ then there exists ¯t ∈ [ak, bk] ∩\n[aq, bq] for which eij(¯t) ∈ Bk\nij∧eij(¯t) ∈ Bq\nij. We thus arrived\nat a contradiction since Bk\nij ∩ Bq\nij = ∅.\nFact 2: (Conflict of type 2) Consider two tasks ϕk\nij and\nϕq\nij defined over the edge (i, j) ∈ E ¯\nψ and such that k ∈ Ig\nij,\nq ∈ If\nij. If [aq, bq] ⊆ [ak, bk] and Bq\nij ∩Bk\nij = ∅ then ϕk\nij ∧ϕq\nij\nis a conflicting conjunction.\nProof:\nWe prove the fact by contradiction. Suppose\nthere exists x(t) such that x(t)\n|=\nϕq\nij ∧ ϕk\nij. Then\nρϕq\nij∧ϕk\nij(x, 0)\n=\nmin{ρϕq\nij(x, 0), ρϕk\nij(x, 0)}\n>\n0\n⇒\nρϕq\nij(x, 0) > 0 ∧ ρϕk\nij(x, 0) > 0. Recalling the definition\nof robust semantics for the F and G operators we have\nhq\nij(eij(t)) > 0 ∀t ∈ [aq, bq] ⇒ eij(t) ∈ Bq\nij ∀t ∈ [aq, bq]\nand there exist ¯t ∈ [ak, bk] such that hk\nij(eij(¯t)) > 0 ⇒\neij(¯t) ∈ Bk\nij. Since [ak, bk] ⊂ [aq, bq] then ¯t ∈ [aq, bq]\nand eij(¯t) ∈ Bk\nij ∧ eij(¯t) ∈ Bq\nij. We thus arrived at the\ncontradiction as Bk\nij ∩ Bq\nij = ∅.\nThe next two facts define conflicting conjunctions over cycles\nof tasks in G ¯\nψ. Indeed, conflicts may arise if the cycle closure\nrelation (4) can not be satisfied under a cycle of tasks in G ¯\nψ.\nNamely, we deal with conjunction of tasks ∧(r,s)∈ϵ(ω)ϕrs\nwhere ω is a cycle of length l in G ¯\nψ and ϕrs is a task of\ntype (13b) or (13c). The case in which each ϕrs is a task of\ntype (13a) that contains conjunctions, is a generalization of\nthis simpler case as we show later. For clarity of presentation,\nwe adopt the notation ϕω[k,k+1] to indicate a task ϕrs such\nthat (r, s) = (ω[k], ω[k+1]) for k ∈ 1, . . . l−1. Likewise, we\ndenote the corresponding time interval, the super-level set,\npredicate function and predicate of ϕω[k,k+1] as [a, b]ω[k,k+1],\nBω[k,k+1], hω[k,k+1] and µω[k,k+1] respectively. We thus have\nthe notational equivalence ∧(r,s)∈ϵ(ω)ϕrs = ∧l−1\nk=1ϕω[k,k+1].\nWe now present the next two types of conflicting conjunc-\ntions.\nFact 3: (Conflict of type 3) Consider a cycle ω of\nlength l in G ¯\nψ such that each edge (ω[k], ω[k + 1]) cor-\nresponds to a unique task ϕω[k,k+1] = G[a,b]µω[k,k+1]. If\nTl−1\nk=1[a, b]ω[k,k+1] ̸= ∅ and\np\nM\nk=1\nBω[k,k+1] ∩\n\u0010\n−\nl−1\nM\nk=p+1\nBω[k,k+1]\n\u0011\n= ∅\n(14)\nfor some 1 ≤ p ≤ l − 1 then Vl−1\nk=1 ϕω[k,k+1] is a conflicting\nconjunction.\nProof:\nWe prove the theorem by contradiction. As-\nsume that there exists a state trajectory x(t) such that\nx(t) |= Vl−1\nk=1 ϕω[k,k+1]. Then we know from the robust\nsatisfaction of such conjunction that ρ\nVl−1\nk=1 ϕω[k,k+1](x, 0) =\nmink=1,...l−1{ρϕω[k,k+1](x, 0)} > 0 ⇒ ρϕω[k,k+1](x, 0) >\n0 ∀k = 1, . . . l − 1. Recalling the definition of robust\nsemantics for the always formulas we can then write\nhω[k,k+1](eω[k,k+1](t))\n>\n0, ∀t\n∈\n[a, b]ω[k,k+1], ∀k\n=\n1, . . . l − 1 and thus eω[k,k+1](t)\n∈\nBω[k,k+1], ∀t\n∈\n[a, b]ω[k,k+1], ∀k = 1, . . . l − 1. We now recall from (4) that\nfor a cycle of edges, we have Pl−1\nk=1 eω[k,k+1](t) = 0 ⇒\nPp\nk=1 eω[k,k+1](t) = − Pl−1\nk=p+1 eω[k,k+1](t) for any 1 ≤\np ≤ l − 2. Since we know that Sl−1\nk=1[a, b]ω[k,k+1] ̸= ∅ then\nthere exist a time instant ¯t ∈ Sl−1\nk=1[a, b]ω[k,k+1] such that\nthe three relations Pp\nk=1 eω[k,k+1](¯t) ∈ Lp\nk=1 Bω[k,k+1],\n− Pl−1\nk=p+1 eω[k,k+1](¯t)\n∈\n\u0000− Ll−1\nk=p+1 Bω[k,k+1]\n\u0001\nand\nPp\nk=1 eω[k,k+1](¯t) = − Pl−1\nk=p+1 eω[k,k+1](¯t) must hold.\nWe thus arrived at a contradiction as the three aforemen-\ntioned conditions can not hold jointly if Lp\nk=1 Bω[k,k+1] ∩\n\u0010\n− Ll−1\nk=p+1 Bω[k,k+1]\n\u0011\n= ∅. Since the argument is indepen-\ndent of the index p chosen, the proof is valid for any chosen\n1 ≤ p ≤ l − 2.\nFact 4: (Conflict of type 4) Consider a cycle ω of length\nl in Gψ such that for each edge (ω[k], ω[k + 1]) there\ncorresponds a unique task ϕω[k,k+1], for which we have\nϕω[k,k+1] = F[a,b]µω[k,k+1]∀k = 1, . . . q and ϕω[k,k+1] =\nG[a,b]µω[k,k+1]∀k = q + 1, . . . l − 1 for some 1 ≤ q ≤ l − 1.\nIf Lp\nk=1 Bω[k,k+1] ∩\n\u0010\n− Ll−1\nk=p+1 Bω[k,k+1]\n\u0011\n̸= ∅ for some\n1 ≤ p ≤ l−1 and if either 1) q = 1, Tl−1\nk=q+1[a, b]ω[k,k+1] ̸=\n∅, [a, b]ω[1,2]\n⊆\nTl−1\nk=q+1[a, b]ω[k,k+1] or 2) q\n≥\n1,\nTl−1\nk=q+1[a, b]ω[k,k+1] ̸= ∅, [a, b]ω[k,k+1] = [¯t, ¯t]∀k = 1, . . . q,\n¯t ∈ Tl−1\nk=q+1[a, b]ω[k,k+1]; then Vl−1\nk=1 ϕω[k,k+1] is a conflict-\ning conjunction.\nProof: The proof is similar to the proof of Fact 3 and\nit is not reported due to space limitation.\nB. Resolving conflicting conjunctions\nDuring the process of rewriting ψ into ¯ψ, it is relevant\nto avoid the insurgence of conflicts 1-4. With this aim, we\nprovide the Lemmas 2-5 which define additional convex\nconstraints on the parameters of the parametric tasks in ¯F.\nWe then include such constraints in (12) to avoid conflicts\nof type 1-4.\nLemma 2: Let (i, j) ∈ E ¯\nψ with task ϕij = ϕs\nij ∧ϕr\nij such\nthat s, r ∈ Ig\nij and [ar, br]∩[as, bs] ̸= ∅. Then, enforcing the\nconvex constraints\nBs\nij ⊆ Br\nij if\n(br − ar) ≥ (bs − as) ∧ ϕr\nij, ϕs\nij ∈ ¯F (15a)\nBr\nij ⊆ Bs\nij if\n(br − ar) < (bs − as) ∧ ϕr\nij, ϕs\nij ∈ ¯F (15b)\nBs\nij ⊆ Br\nij if\nϕr\nij ∈ F, ϕs\nij ∈ ¯F\n(15c)\nwhere F and ¯F are the sets of non-parametric and parametric\ntasks respectively, ensures that ϕs\nij ∧ ϕr\nij is not a conflicting\nconjunction of type 1.\nProof: Let [ar, br] ∩ [as, bs] ̸= ∅, then (15) contradicts\nthe conditions of conflicting conjunction of type 1 according\nto Fact 1.\nConstraints (15a)-(15b) specify that when two parametric\nformulas could be in conflict according to Fact 1, then we\ndecide to include the super-level set of tasks with shorter\ntime intervals into the ones with longer time intervals.\nLemma 3: Let (i, j) ∈ E ¯\nψ with task ϕij = ϕs\nij ∧ϕr\nij such\nthat s ∈ Ig\nij, r ∈ If\nij and [ar, br] ⊆ [as, bs]. Then, enforcing\nthe convex constraints\nBr\nij ⊆ Bs\nij\nif\nϕs\nij ∈ F, ϕr\nij ∈ ¯F\n(16a)\nBs\nij ⊆ Br\nij\nif\nϕs\nij ∈ ¯F, ϕr\nij ∈ F\n(16b)\nBr\nij ⊆ Bs\nij\nif\nϕs\nij ∈ ¯F, ϕr\nij ∈ ¯F\n(16c)\nwhere F and ¯F are the sets of non-parametric and parametric\ntasks respectively, ensure that ϕs\nij ∧ ϕr\nij is not a conflicting\nconjunction of type 2.\nProof: Let [ar, br] ⊆ [as, bs], then (16) contradicts the\nconditions of conflicting conjunction of type 2 according to\nFact 2.\nWhen more than two tasks are considered in conjunction,\nthen Lemma 2-3 can be applied to every possible couple of\ntasks in the conjunction.\nLemma 4: Let ω be a cycle of length l in G ¯\nψ such that\nfor each (ω[k], ω[k + 1]) there corresponds a unique task\nϕω[k,k+1] = G[a,b]µω[k,k+1]. If Tl−1\nk=1[a, b]ω[k,k+1] ̸= ∅ then\nimposing the constraints\np\nM\nk=1\nBω[k,k+1] ⊆\n\u0010\n−\nl−1\nM\nk=p+1\nBω[k,k+1]\n\u0011\n(17)\nfor some 1 ≤ p ≤ l − 1, ensures that Vl−1\nk=1 ϕω[k,k+1] is not\na conflicting conjunction of type 3.\nProof: Relation (17) is a special case of the set inclu-\nsion in (14). Since we considered Tl−1\nk=1[a, b]ω[k,k+1] ̸= ∅,\nthen (17) contradicts (14) as per Fact 3.\nLemma 5: Let\nω\nbe\na\ncycle\nof\nlength\nl\nin\nGψ\nsuch that for each edge (ω[k], ω[k + 1]) there cor-\nresponds\na\nunique\ntask\nϕω[k,k+1].\nArbitrarily\nassume\nϕω[k,k+1] = F[a,b]µω[k,k+1]∀k = 1, . . . q and ϕω[k,k+1] =\nG[a,b]µω[k,k+1]∀k = q + 1, . . . l − 1 for some 1 ≤ q ≤ l − 1.\nIf either 1) q = 1, Tl−1\nk=q+1[a, b]ω[k,k+1] ̸= ∅, [a, b]ω[1,2] ⊆\nTl−1\nk=q+1[a, b]ω[k,k+1], or 2) q ≥ 1, Tl−1\nk=q+1[a, b]ω[k,k+1] ̸= ∅,\n[a, b]ω[k,k+1] = [¯t, ¯t]∀k = 1, . . . q, ¯t ∈ Tl−1\nk=q+1[a, b]ω[k,k+1];\nthen imposing (17) ensures that Vl−1\nk=1 ϕω[k,k+1] is not a\nconflicting conjunction of type 4.\nProof: The proof is similar to the proof of Lemma 4\nand it is not reported due to space limitations.\nRemark 3: In the statement of Lemmas 4-5 we con-\nsidered that no edge of a cycle ω contains conjunctions.\nNevertheless, in the case ϕω[k,k+1] contains conjunctions as\nϕω[k,k+1] = V\ns∈Ig\nω[k,k+1] ϕs\nω[k,k+1] ∧ V\ns∈If\nω[k,k+1] ϕs\nω[k,k+1]\naccording to (13a), it is possible to define the combination\nset C = Ql−1\nk=1 Iω[k,k+1] where Iω[k,k+1] contains all the\ntasks indices for edge (ω[k], ω[k + 1]) as per (13a). Then,\nfor each combination of indices c ∈ C we can check\nif the conjunction ∧l−1\nk=1ϕc[k]\nω[k,k+1] satisfies the conditions\nfor conflicting conjunctions of type 3-4 and introduce new\nconstraints of type (17) accordingly.\nRemark 4: The computation of the Minkowski sum in\n(17) can possibly become a complex computation as not all\nthe tasks defined over a cycle ω are parametric as per (8).\nNevertheless, we can under-approximate the sets Bω[k,k+1]\nsuch that ϕω[k,k+1] ∈ F by a hyper-rectangle that can be\ncomputed offline when ψ is defined. [19].\nWe conclude this section with the final result of our work.\nTheorem 2: Let the conditions of Theorem 1 be satisfied.\nIf a solution to the convex optimization problem (12) exists\nafter the inclusion of constraints (15), (16), (17), then the\nresulting global formula ¯ψ defined as in (9) from Thm. 1\ndoes not contain conflicting conjunctions as per Fact 1-4.\nProof: Follows directly from Lemmas 2-5.\nThus, Theorem 2 resolves the feasibility issues that were\nnot considered in Theorem 1 so that ¯ψ does not suffer from\nconflicting conjunctions according to Fact 1-4.\nVI. SIMULATIONS\nWe showcase our decomposition approach for a forma-\ntion problem of 8 agents such that V := {1, . . . 8}. For\nthis task, we assume the agents to be governed by single\nintegrator dynamics ˙xi = ui where xi = [xi, yi]T ∈ R2\nrepresents the position of the agents in a 2-dimensional\nspace. We consider a time-varying formation task divided\ninto two parts. First, a star formation needs to be achieved\ngiven by the tasks: ϕ85 = G[10,15](||e85 − [−15, 15]T || ≤\n3), ϕ52 = G[10,15](||e25 − [−15, −15]T || ≤ 3), ϕ34 =\nG[10,15](||e34 − [15, −15]T || ≤ 3), ϕ74 = G[10,15](||e74 −\n[15, 15]T || ≤ 3), ϕ46 = G[10,15](||e46 − [10, −10]T || ≤ 2),\nϕ56 = G[10,15](||e56 − [−10, −10]T || ≤ 2). Second, the\nteam of agents V1 = {6, 7, 8} and V2 = {1, 2, 3} get\ndetached by the initial star formation such that agents 1\nand 6 move independently toward the region x > 5, y > 5\nand x > 5, y < −5 respectively while team V1 and V2\nachieve a triangle formation from t = 25s to t = 28s.\nThis second part of the formation is given by specifications\nϕ1 = F[25,28]([−1, 0](x1 − [5, 0]T ) ≤ 0) ∧ ([0, −1](x1 −\n[0, −5]T ) ≤ 0, ϕ6\n= F[25,28]([−1, 0](x6 − [5, 0]T ) ≤\n0) ∧ ([0, −1](x6 − [0, 5]T ) ≤ 0, ϕ32 = G[25,28](||e32 −\n[16, 0]T || ≤ 2\n√\n2), ϕ87 = G[25,28](||e87 − [16, 0]T || ≤\n2\n√\n2), ϕ21 = G[25,28](||e21 − [−8, −8]T || ≤ 2\n√\n2), ϕ68 =\nG[25,28](||e68 − [−8, 8]T || ≤ 2\n√\n2). The global task ψ is\nthe conjunction of the given tasks. We use the open-source\noptimization library CasADi which leverages an interior-\npoint method algorithm to solve the convex program in (12)\nand find ¯ψ. The algorithm converged to an optimal solution\nin 0.019s running on an Intel-Core i7-1265U × 12 with\n32 GB of RAM. In order to satisfy ¯ψ, we apply a fully\ndistributed control barrier function-based controller similar\nto the approach proposed previously in [4] so that each agent\ni ∈ V needs only state information of its 1-hop neighbours\nin Nc(i) to compute its local control ui. The graphs Gψ, Gc\nand G ¯\nψ for the simulation are given in Fig. 3c. The tasks\nϕ25, ϕ32, ϕ34, ϕ74, ϕ85 and ϕ78 are decomposed according\nto Table I. The agents’ trajectories are simulated from t = 0\nto t = 28 and shown in Fig. 3a-3b.\nVII. CONCLUSIONS\nWe presented a framework STL task decomposition based\non the communication graph of multi-agent systems. We\nshowed that the newly defined tasks imply the original ones\nwhen a valid decomposition is obtained. We additionally\ngave a set of Facts describing four possible conflicting\n30\n30\n20\n10\n0\n10\n20\n30\n30\n20\n10\n0\n10\n20\n(a)\n30\n30\n20\n10\n0\n10\n25\n20\n15\n10\n10\n5\n0\n5\n(b)\n(c)\nFig. 3: Trajectory evolution of the agents from time t = 0s to t = 15s (a) and from time t = 15s to t = 28s (b); Short\nsolid arrows represent the direction of movement of the agents; green lozenges represent the starting positions of the agents,\nwhile black stars represent the final positions. Communication graph Gc, initial task graph Gψ and final task graph G ¯\nψ (c).\nEdges (2, 5), (3, 2), (3, 4), (7, 4), (8, 5), and (7, 8) in Gψ are decomposed over the edges of Gc to obtain G ¯\nψ.\nϕπ2\n5\nπ2\n5 = [5, 1, 2]\nϕπ3\n2\nπ3\n2 = [2, 1, 3]\n¯ϕπ2\n5\n51\n¯ϕπ2\n5\n12\n¯ϕπ3\n2\n21\n¯ϕπ3\n2\n13\np\nπj\ni\nrs\n[9.99, -4.34]\n[24.99, -10.65]\n[7.99, 7.99]\n[7.99, -7.99]\nν\nπj\ni\nrs\n[0.47, 0.47]\n[1.65, 1.62]\n[0.95, 0.95]\n[1.25, 1.26]\nϕπ3\n4\nπ3\n4 = [4, 1, 3]\nϕπ7\n4\nπ7\n4 = [4, 6, 7]\n¯ϕπ3\n4\n41\n¯ϕπ3\n4\n13\n¯ϕπ7\n4\n46\n¯ϕπ7\n4\n67\np\nπj\ni\nrs\n[-9.99, -4.35]\n[24.99, -10.65]\n[-9.99, 9.99]\n[25.00, 5.00]\nν\nπj\ni\nrs\n[0.47, 0.47]\n[1.62, 1.62]\n[1.89, 1.89]\n[0.91, 0.91]\nϕπ8\n5\nπ8\n5 = [5, 6, 8]\nϕπ7\n8\nπ7\n8 = [8, 6, 7]\n¯ϕπ8\n5\n56\n¯ϕπ8\n5\n68\n¯ϕπ7\n8\n67\n¯ϕπ7\n8\n86\np\nπj\ni\nrs\n[10.00, 10.00]\n[-25.00, 5.00]\n[7.99, -7.99]\n[7.99, 7.99]\nν\nπj\ni\nrs\n[1.89, 1.89]\n[0.91, 0.91]\n[0.950.95]\n[1.26, 1.26]\nTABLE I: Decomposed tasks ϕ25, ϕ32, ϕ34, ϕ74, ϕ85 and\nϕ78 with respective parameters.\nconjunctions related to the applied STL fragment. We then\nprovided a set of convex constraints, under which such\nconflicts can be avoided during the decomposition. In future\nwork, we will investigate task decomposition under time-\nvarying communication topology and more complex param-\neterization for task decomposition.\nREFERENCES\n[1] D. Sun, J. Chen, S. Mitra, and C. Fan, “Multi-agent motion plan-\nning from signal temporal logic specifications,” IEEE Robotics and\nAutomation Letters, vol. 7, no. 2, pp. 3451–3458, 2022.\n[2] F. S. Barbosa, D. Duberg, P. Jensfelt, and J. Tumova, “Guiding\nautonomous exploration with signal temporal logic,” IEEE Robotics\nand Automation Letters, vol. 4, no. 4, pp. 3332–3339, 2019.\n[3] L. Lindemann and D. V. Dimarogonas, “Control barrier functions for\nsignal temporal logic tasks,” IEEE control systems letters, vol. 3, no. 1,\npp. 96–101, 2018.\n[4] L. Lindemann and D. V. Dimarogonas, “Control barrier functions\nfor multi-agent systems under conflicting local signal temporal logic\ntasks,” IEEE Control Systems Letters, vol. 3, no. 3, pp. 757–762, 2019.\n[5] L. Lindemann, C. K. Verginis, and D. V. Dimarogonas, “Prescribed\nperformance control for signal temporal logic specifications,” in 56th\nIEEE Conference on Decision and Control, pp. 2997–3002, 2017.\n[6] F. Chen and D. V. Dimarogonas, “Distributed control of coupled\nleader-follower multi-agent systems under spatiotemporal logic tasks,”\nin IFAC World Congress, 2023.\n[7] N. Mehdipour, C.-I. Vasile, and C. Belta, “Arithmetic-geometric mean\nrobustness for control from signal temporal logic specifications,” in\n2019 American Control Conference (ACC), pp. 1690–1695.\n[8] V. Raman, A. Donz´e, M. Maasoumy, R. M. Murray, A. Sangiovanni-\nVincentelli, and S. A. Seshia, “Model predictive control with signal\ntemporal logic specifications,” in 53rd IEEE Conference on Decision\nand Control, pp. 81–87, 2014.\n[9] Z. Liu, J. Dai, B. Wu, and H. Lin, “Communication-aware motion\nplanning for multi-agent systems from signal temporal logic specifica-\ntions,” in 2017 American Control Conference (ACC), pp. 2516–2521.\n[10] G. A. Cardona, D. Kamale, and C.-I. Vasile, “Mixed integer linear\nprogramming approach for control synthesis with weighted signal tem-\nporal logic,” in Proceedings of the 26th ACM International Conference\non Hybrid Systems: Computation and Control, pp. 1–12, 2023.\n[11] M. Charitidou and D. V. Dimarogonas, “Signal temporal logic task de-\ncomposition via convex optimization,” IEEE Control Systems Letters,\nvol. 6, pp. 1238–1243, 2021.\n[12] K. Leahy, A. Jones, and C.-I. Vasile, “Fast decomposition of temporal\nlogic specifications for heterogeneous teams,” IEEE Robotics and\nAutomation Letters, vol. 7, no. 2, pp. 2297–2304, 2022.\n[13] K. Leahy, M. Mann, and C.-I. Vasile, “Rewrite-based decomposition\nof signal temporal logic specifications,” in NASA Formal Methods\nSymposium, pp. 224–240, Springer, 2023.\n[14] O. Maler and D. Nickovic, “Monitoring temporal properties of con-\ntinuous signals,” in International Symposium on Formal Techniques in\nReal-Time and Fault-Tolerant Systems, pp. 152–166, Springer, 2004.\n[15] S. Sadraddini and C. Belta, “Robust temporal logic model predictive\ncontrol,” in 53rd Annual Allerton Conference on Communication,\nControl, and Computing, pp. 772–779, IEEE, 2015.\n[16] S. S. Farahani, V. Raman, and R. M. Murray, “Robust model predictive\ncontrol for signal temporal logic synthesis,” IFAC, vol. 48, no. 27,\npp. 323–328, 2015.\n[17] V. Raman, A. Donz´e, D. Sadigh, R. M. Murray, and S. A. Seshia,\n“Reactive synthesis from signal temporal logic specifications,” in\nProceedings of the 18th international conference on hybrid systems:\nComputation and control, pp. 239–248, 2015.\n[18] S. M. LaValle, Planning algorithms. Cambridge university press, 2006.\n[19] G. M. Ziegler, Lectures on polytopes, vol. 152. Springer Science &\nBusiness Media, 2012.\n[20] S. Froitzheim, Efficient conversion of geometric state set representa-\ntions for hybrid systems. PhD thesis, Bachelor’s thesis. RWTH Aachen\nUniversity, 2016.\n"
}