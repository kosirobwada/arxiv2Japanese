{
    "optim": "Communication-Constrained STL Task Decomposition through Convex Optimization Gregorio Marchesini, Siyuan Liu, Lars Lindemann and Dimos V. Dimarogonas Abstract— In this work, we propose a method to decompose signal temporal logic (STL) tasks for multi-agent systems subject to constraints imposed by the communication graph. Specifically, we propose to decompose tasks defined over multi- ple agents which require multi-hop communication, by a set of sub-tasks defined over the states of agents with 1-hop distance over the communication graph. To this end, we parameterize the predicates of the tasks to be decomposed as suitable hyper- rectangles. Then, we show that by solving a constrained convex optimization, optimal parameters maximising the volume of the predicate’s super-level sets can be computed for the decomposed tasks. In addition, we provide a formal definition of conflicting conjunctions of tasks for the considered STL fragment and a formal procedure to exclude such conjunctions from the solution set of possible decompositions. The proposed approach is demonstrated through simulations. I. INTRODUCTION Temporal logics have recently received increasing atten- tion as they allow for expressing high-level collaborative tasks among agents in a multi-agent system (MAS). Among the different temporal logics, signal temporal logic (STL) is an expressive language that has been successfully applied for both high-level planning [1], [2] and low-level feedback control [3], [4] of multi-agent systems. The possibility of expressing both the temporal and spatial behavior of MASs without leveraging abstraction-based techniques makes STL particularly appealing for real-time control and planning by avoiding the curse of dimensionality. At the current state of the art, three main low-level control approaches have been developed for the satisfaction of high- level STL tasks for MASs: prescribed performance control [5], [6], mixed-integer linear programs (MILP) [7], [8], [9], [10], and time-varying control barrier functions (CBF) [3], [4]. In all the aforementioned works, it is taken for granted that the connectivity of the communication networks is ensured and always compatible with the task dependency graphs of MASs. Indeed, it is commonly assumed that each agent has either global state information about the system, or that agents involved in the same tasks can share state information by leveraging 1-hop communication. Neverthe- less, this assumption is commonly violated in many real- This work was supported in part by the Horizon Europe EIC project SymAware (101070802), the ERC LEAFHOUND Project, the Swedish Research Council (VR), Digital Futures, and the Knut and Alice Wallenberg (KAW) Foundation. Gregorio Marchesini, Siyuan Liu, and Dimos V. Dimarogonas are with the Division of Decision and Control Systems, KTH Royal Institute of Technology, Stockholm, Sweden. E-mail: {gremar,siyliu,dimos}@kth.se. Lars Lindemann is with the Thomas Lord Department of Computer Science, University of Southern California, Los Angeles, CA, USA. E-mail: {llindema}@usc.ed. world scenarios and fully decentralised control can not be achieved by the previous low-level control approaches when this assumption is not met. In this work, we propose a first step toward relaxing such assumption by decomposing tasks defined over multiple agents subject to multi-hop communication into conjunctions of sub-tasks that can be achieved by leveraging only 1-hop communication over the communication graph. The results in [11] established a paradigm to decompose STL tasks defined over MASs into a set of tasks that can be independently satisfied by distinct sub-clusters of agents. However, the mismatch between the communication graph and task dependency graph of the MASs is not considered in the decomposition process, while each sub-cluster is con- sidered to be fully connected. Similarly, [12] and [13] employ MILP to achieve the same type of decomposition as in [11], but the underlying communication topology of the multi- agent system is again not considered, and thus decentralised control cannot be leveraged in the absence of fully connected sub-clusters. In [9], communication constraints are consid- ered in the motion planning approach of MASs. A MILP is solved to compute a valid state trajectory for the MAS that satisfies a global STL task, while maintaining an optimized inter-agent communication quality of service. Nevertheless, perfect inter-agent communication is still assumed for agents under the same collaborative tasks. The main contributions of this work are twofold. First, we propose a communication-constrained decomposition for a fragment of STL tasks defined over the absolute and relative state of the agents in the MAS. Namely, we exploit the communication graph of the MAS to decompose tasks whose predicate functions depend on the agents which require multi-hop communication into a conjunction of sub-tasks defined over the agents that have one 1-hop communication. Each newly introduced sub-task is defined over a parametric predicate function depending on the relative state of couples of agents in the system linked by the communication graph. By leveraging convex optimization tools, optimal parameters for each sub-task are then computed such that the volume of the super-level set of the predicate functions is maximised [11]. The decomposed tasks allow for a fully decentralised control approach for MASs. Second, we formally derive a set of conditions that can lead to un-satisfiable conjunctions of tasks in the considered STL fragments. We also provide a set of convex constraints to be included in the original convex optimization such that un-satisfiable conjunctions of tasks are excluded from the solution set of our task decomposition. The paper is organized as follows. Section II presents pre- arXiv:2402.17585v1  [eess.SY]  27 Feb 2024 liminaries and Section III introduces the problem definition. Section IV proposes our main task decomposition result. In Section V, we provide a formal definition of conflicting con- junctions of tasks and then propose a strategy to avoid such conflicts. Simulation results are provided in Section VI to demonstrate our decomposition approach, while concluding remarks are given in Section VII. Notation: Bold letters indicate vectors while capital let- ters indicate matrices. Vectors are considered to be column vectors and the notation x[k] indicates the k-th element of x. We define the minimum of a vector a ∈ Rn element- wise as ⋆ min(a) := mink=1,...n{a[k]}. The notation |A| denotes the cardinality of the set A, the symbol ⊕ indicates the Minkowski sum, the notation Qk i=1 Ai represents the Cartesian product of the sets Ai and −A = {x|x = −v ∀v ∈ A}. We denote the power set of A as P(A). The identity matrix of dimension n is denoted as In. The set R+ denotes the non-negative real numbers. II. PRELIMINARIES Let V = {1, . . . N} be the set of indices assigned to each agent in a multi-agent system. We write the input-affine nonlinear dynamics for each agent i ∈ V as ˙xi = fi(xi) + gi(xi)ui (1) where xi ∈ Xi ⊂ Rni is the state of the i-th agent and ui ∈ Ui ⊂ Rmi is the associated bounded control input. We assume, without loss of generality, that ni = n, ∀i ∈ V. Let fi : Rn → Rn and gi : Rn → Rn×mi be locally Lipschitz continuous functions of the agent state. We denote the full state of the system as x := [xT 1 , xT 2 , . . . xT N]T . Given a control input ui : [t0, t1] → Ui, we define the state trajectory xi : [t0, t1] → Xi for agent i ∈ V if xi(t) satisfies (1) for all t ∈ [t0, t1]. We Also define the relative state vector eij := xj − xi for i, j ∈ V. A. Signal Temporal Logic STL is a predicate logic applied to formally define spa- tial and temporal behaviours of real-valued continuous-time signals [14]. The atomic elements of STL are Boolean predicates µ : R → {⊤, ⊥} defined as µ := \b ⊤ if h(x)≥0 ⊥ if h(x)<0, where h(x) : Rn → R is a scalar valued predicate function. The value of h can generally depend upon the state of all the agents of the multi-agent system or a subset of the former. The STL grammar is recursively defined as: ϕ ::= ⊤|µ|¬ϕ|ϕ1 ∧ ϕ2|F[a,b]ϕ|G[a,b]ϕ|ϕ1U[a,b]ϕ2 where F[a,b], G[a,b] and U[a,b] are the temporal eventually, always and until operators over the time interval [a, b] ⊂ R+. We indicate that a state trajectory x(t) satisfies task ϕ at time t as x(t) |= ϕ. The classical STL semantics define the conditions such that x(t) |= ϕ [14]. In the current work, we leverage the robust quantitative STL semantics: ρµ(x, t) = h(x(t)), ρ¬ϕ(x, t) = −ρϕ(x, t), ρϕ1∧ϕ2(x, t) = min \u0000ρϕ1(x, t), ρϕ2(x, t) \u0001 , ρϕ1U[a,b]ϕ2(x, t) = maxt1∈[t+a,t+b] min \u0000ρϕ2 (x, t1) , mint2∈[t,t1] ρϕ1 (x, t2) \u0001 , ρF[a,b]ϕ(x, t) = maxt1∈[t+a,t+b] ρϕ (x, t1) , ρG[a,b]ϕ(x, t) = mint1∈[t+a,t+b] ρϕ (x, t1) , and we recall the relations ρϕ(x, 0) > 0 ⇒ x(t) |= ϕ [15], [16], [17]. In this work, we focus on STL tasks defined over predicate functions that depend on the state xi of a single agent and/or on the relative state vector eij between two agents. Namely, we make use of the following STL fragment: ϕi := F[a,b]µi|G[a,b]µi|ϕ1 i ∧ ϕ2 i , (2a) ϕij := F[a,b]µij|G[a,b]µij|ϕ1 ij ∧ ϕ2 ij, (2b) where µi := \b ⊤ if hi(xi)≥0 ⊥ if hi(xi)<0, , µij := \b ⊤ if hij(eij)≥0 ⊥ if hij(eij)<0, with predicate functions hi(xi) and hij(eij). We refer to tasks as per (2a) as independent and tasks as per (2b) as collaborative. Additionally, we identify the respective super-level sets as Bi = {xi ∈ Xi|hi(xi) ≥ 0}; Bij = {eij ∈ Xi ⊕ (−Xj)|hij(eij) ≥ 0}. (3) B. Communication and Task Graphs We define an undirected graph over the set of agents V as G(V, E) ∈ Γ, where E ⊆ V × V is the set of undirected edges of G and Γ is the set of undirected graphs over the nodes V. We define the set of neighbours of vertex i as N(i) = {j|(i, j) ∈ E ∧ i ̸= j} and the extended neighbour set as ¯ N(i) := N ∪ {i} such that self-loops are considered. Let the graph-valued function add(·, ·) : Γ × V × V → Γ be such that G′(E′, V) = add(G, Q) with E′ = E ∪ Q for a given set of edges Q ⊂ V ×V. Similarly we define del(·, ·) : Γ × V × V → Γ such that G′(E′, V) = del(G, Q) and E′ = E \\ Q. Let the vector πj i ∈ Vl represent a directed path of length l defined as a vector of non-repeated indices in V such that πj i [k] ∈ V ∀k = 1, . . . l , πj i [r] ̸= πj i [s] ∀s ̸= r , (πj i [r], πj i [r + 1]) ∈ E and (πj i [1], πj i [l]) = (i, j). Let ω ∈ Vl represent a directed closed cycle path, such that ω is a directed path and ω[1] = ω[l]. Let ϵ : Vl → P(E) be a set- valued function such that ϵ(πj i ) = {(πj i [k], πj i [k + 1])|k = 1, . . . l − 1}. We establish the relations eij = X (r,s)∈ϵ(πj i ) ers, 0 = X (r,s)∈ϵ(ω) ers. (4) We further make a distinction between two types of graphs that refer to a multi-agent system. Namely, we define the communication graph Gc(V, Ec) ∈ Γ such that (i, j) ∈ Ec ⊂ V × V if i and j are able to communicate their respective state to each other. It is assumed that each agent is always able to communicate with itself. We also define the task graph Gψ(V, Eψ) ∈ Γ such that (i, j) ∈ Eψ if there exists a collaborative task ϕij as per (2b) between agent i and j. Independent tasks ϕi as per (2a) induce self-loops in the task graph (see in Fig. 1). We repeatedly make use of the subscript c and ψ to differentiate among properties of the communication and task graph, respectively. For instance, Nc(i) and Nψ(i) indicate the neighbour set of agent i in the communication graph and task graph, respectively. We define ψ as the global task assigned to the MAS as ψ := N ^ i=1  ϕi ∧ ^ j∈Nψ(i) ϕij   . (5) Fig. 1: Simple example of communication (left) and task graph (right) for a multi-agent system with 6 agents. The task and communication graph are mismatching in their case. Global tasks according to (5) are particularly suitable for defining, e.g. time-varying relative formations. We propose an example to clarify the notation introduced so far. Example 1: Consider the communication and task graphs in Fig 1. Agents 2 and 5 have an independent task ϕ2, ϕ5 respectively, while ϕ12, ϕ13, ϕ14, ϕ16, ϕ56, ϕ26 are collabora- tive tasks. The path π3 1 = [1, 2, 3] connects agent 1 to 3 with length l = 3 and ϵ(π3 1) = {(1, 2), (2, 3)}. Likewise, π2 6 = [6, 1, 2] and ϵ(π2 6) = {(6, 1), (1, 2)}. Agents 1, 2, 6 form a cycle of tasks ω = [1, 2, 6, 1] in Gψ. We conclude this section by stating the three main assump- tions that hold throughout the work: Assumption 1: (Connectivity) The communication graph Gc is a time-invariant connected graph. Assumption 2: (Concavity) The predicate functions hij and hi are concave functions of eij and xi respectively. Assumption 3: (Task symmetry) For each STL task ϕij in (2b), we have that ϕij = ϕji ∀(i, j) ∈ Eψ. The first assumption is required to obtain a decomposition and ensure that such decomposition remains valid over time. We leave the case of time-varying Gc as future work. The second assumption is required to maintain the super-level sets Bij in (3) convex. Note that the same assumptions were considered in [11] for a similar task decomposition. The last Assumption 3 is not restrictive since the Gψ is undirected. III. PROBLEM FORMULATION Previous works in STL control often assume that Gc is fully connected or that ψ can be decomposed into a conjunction of tasks defined over the state of fully connected sub-clusters of agents in Gc. In the current work, we seek to drop these assumptions. Indeed, given the structure of ψ as a conjunction of collaborative tasks among couples of agents or independent tasks, then the satisfaction of ψ can be achieved by designing a fully decentralised low-level controller for each agent i, requiring only state information from the 1-hop neighbours in Nc(i) when Nψ(i) ⊆ Nc(i) [4]. However, a decentralised control approach that can guarantee the satisfaction of ψ when Nψ(i) ̸⊆ Nc(i) is not available in the literature. Thus, we wish to exploit Gc to construct a new task ¯ψ in the form of (5) and a new graph G ¯ ψ such that N ¯ ψ(i) ⊆ Nc(i) and (x, t) |= ¯ψ ⇒ (x, t) |= ψ. With this goal, we decompose the original tasks ϕij, with Fig. 2: Example of decomposition according to (7). (i, j) ∈ Eψ \\ Ec, over the relative states of a path of agents πj i over Gc. We formalise the problem as follows: Problem 1: Consider the multi-agent system with agents in V, communication graph Gc and task graph Gψ such that ψ is according to (5) and Eψ \\ Ec ̸= ∅. Then, define a new global task ¯ψ in the form ¯ψ := N ^ i=1  ϕi ∧ ^ j∈Nψ(i)∩Nc(i) ϕij ∧ ^ j∈Nψ(i)\\Nc(i) ϕπj i   , (6) with the new task graph being G ¯ ψ, such that ∀(i, j) ∈ Eψ \\Ec ϕπj i := ^ (r,s)∈ϵ(πj i ) ¯ϕ πj i rs, (7) where πj i are paths in Gc such that ϵ(πj i ) ⊂ Ec and ¯ϕ πj i rs are tasks of type (2b) to be appropriately defined such that x(t) |= ¯ψ implies x(t) |= ψ. Example 2: Consider Fig 2. Agents 1 and 4 share a collaborative task ϕ14, which cannot be directly satisfied as the two agents are not communicating (indicated by a dashed line). The task ϕ14 is then replaced by the task ϕπ4 1 = ¯ϕπ4 1 12 ∧ ¯ϕπ4 1 23 ∧ ¯ϕπ4 1 34 where π4 1 = [1, 2, 3, 4]. In the next sections, we will develop on how the tasks ¯ϕ πj i rs are defined according to Gc and the temporal properties of the collaborative tasks ϕij with (i, j) ∈ Eψ \\ Ec. IV. TASK DECOMPOSITION We outline the task decomposition approach applied to obtain a single task ϕπj i , according to (7), from a given collaborative task ϕij = T[a,b]µij with T ∈ {G, F} as defined in (2b) (see Fig. 2). In the case where ϕij contains conjunctions of tasks as ϕij = V k ϕk ij, the method developed in this section is applied for each ϕk ij, leading to ϕij being decomposed as ϕπj i = V k(ϕπj i )k. Each (ϕπj i )k is obtained with the same approach applied in the single task case presented in this section. We further elaborate on this point in Remark 2. A. Path decomposition of STL tasks Constructing task ϕπj i requires two steps: 1) find a path πj i from agents i to j through Gc, 2) find a family of tasks ¯ϕ πj i rs that can be applied to construct ϕπj i as per (7) such that x(t) |= ϕπj i ⇒ x(t) |= ϕij. The solution to step 1 is readily available from the literature as there exists a plethora of algorithms for finding a path from node i to node j in a connected graph [18]. We highlight that finding the shortest path connecting two nodes is not a requirement for our work and thus we select the well-known Dijkstra algorithm. On the other hand, for the solution of step 2, we leverage axis-aligned n-dimensional hyper-rectangles as suitable predicate functions for the tasks ¯ϕ πj i rs [19], [20]. The following definitions and properties of hyper-rectangles are provided: Definition 1: ([19, Ch .1.1][20, Def 3.6]) Given ν ∈ Rn such that ν[k] ∈ R+ ∀k ∈ 1, . . . n and p ∈ Rn, an axis- aligned hyper-rectangle H(p, ν) is defined as H(p, ν) = Qn k=1[p[k]−ν[k]/2, p[k]+ν[k]/2]. Equivalently, H(p, ν) = {ζ ∈ Rn|A(ζ − p) − b(ν) ≥ 0} such that b(ν) = [νT /2, −νT /2] and A = [In, −In]T . Proposition 1: ([19, Ch. 1.1]) Any point ζ ∈ H(p, ν) is a convex combination of the set of vertices P(p, ν) := {v ∈ Rn|v[s] = p[s] + ν[s]/2 or v[s] = p[s] − ν[s]/2 ∀s = 1, . . . n}, where |P(p, ν)| = 2n, such that ζ = P2n i=1 λivi, with P2n i λi = 1, 0 ≥ λi ≥ 1 and vi ∈ P(p, ν). Proposition 2: ([20]) Let two axis aligned hyper- rectangles H1(p1, ν1), H2(p2, ν2), then the Minkowski sum H3(p3, ν3) = H1(p1, ν1) ⊕ H2(p2, ν2) is an axis aligned hyper-rectangle such that p3 = p1 + p2 and ν3 = ν1 + ν2. Proposition 3: ([19]) Consider a concave scalar-valued function g : Rn → R and hyper-rectangle H(p, ν). If g(vi) ≥ 0 ∀vi ∈ P(p, ν) then g(ζ) ≥ 0 ∀ζ ∈ H(p, ν). If for each task ¯ϕ πj i rs with (r, s) ∈ ϵ(πj i ) we define a centre p πj i rs and a dimension vector ν πj i rs as parameters, we can employ the following family of concave predicate functions with respective predicate and super-level set: ¯h πj i rs(ers, η πj i rs ) := ⋆ min(A(ers − p πj i rs) − b(ν πj i rs )) ≥ 0, (8a) ¯B πj i rs (η πj i rs ) := {ers ∈ Xr ⊕ (−Xs)|¯h πj i rs(ers, η πj i rs ) ≥ 0}, (8b) ¯µ πj i rs(η πj i rs ) :=    ⊤ if ¯h πj i rs(ers, η πj i rs ) ≥ 0 ⊥ if ¯h πj i rs(ers, η πj i rs ) < 0, (8c) where η πj i rs := [(p πj i rs)T , (ν πj i rs )T ]T are free parameters. We recall that ⋆ min is the element-wise minimum and ⋆ min(A(ζ− p) − b) ≥ 0 ⇒ A(ζ − p) − b ≥ 0 for a given ζ. The vector η πj i rs is computed as a result of the convex program defined in Theorem 1. The parametric set ¯B πj i rs in (8b) is a convex hyper-rectangle by Def. 1 with volume given by Qn s=1 ν πj i rs [s] [16]. Hyper-rectangles are particularly suitable for the task decomposition due to their efficient vertex representation and Minkowski computation in Proposition 2 [16, Sec. 3.6]. In principle, any zonotope can be used for the decomposition presented as we clarify in Remark 2. We can now state our first decomposition result: Lemma 1: Consider a task ϕij = T[a,b]µij with T ∈ {G, F} according to (2b), the corresponding predicate func- tion hij satisfying Assumption 2 and Bij according to (3). Further consider a path πj i through the communication graph Gc and ϕπj i = V (r,s)∈ϵ(πj i ) ¯ϕ πj i rs such that each ¯ϕ πj i rs is defined as ¯ϕ πj i rs :=    F[a∗,b∗]¯µ πj i rs if T = F (9a) G[a∗,b∗]¯µ πj i rs if T = G, , (9b) with [a∗, b∗] defined as [a∗, b∗] := ( \u0002¯t, ¯t \u0003 with ¯t ∈ [a, b] if T = F (10a) \u0002 a, b \u0003 if T = G, (10b) where the predicate ¯µ πj i rs(η πj i rs ), predicate function ¯h πj i rs(ers, η πj i rs ) and super-level set ¯B πj i rs (η πj i rs ) are as per (8). If ¯ϕ πj i rs are defined according to (9)-(10) and M (r,s)∈ϵ(πj i ) ¯B πj i rs (η πj i rs ) ⊆ Bij; (11) then x(t) |= ϕπj i ⇒ x(t) |= ϕij. Proof: We prove the lemma for ϕij := F[a,b]µij while the case of ϕij := G[a,b]µij follows a similar procedure. We omit the dependency of ¯h πj i rs, B πj i rs from η πj i rs to reduce the burden of notation. Given the path πj i over Gc we define ϕπj i = V (r,s)∈ϵ(πj i ) ¯ϕ πj i rs = V (r,s)∈ϵ(πj i ) F[¯t,¯t]¯µ πj i rs according to (9)-(10), where [¯t, ¯t] ⊆ [a, b]. It is known that x(t) |= ϕπj i ⇒ ρϕπj i (x, 0) = min(r,s)∈ϵ(πj i ){ρ ¯ϕ πj i rs (x, 0)} > 0. By defini- tion of robust semantics for the F operator we know that ρ ¯ϕ πj i rs (x, 0) > 0 ⇒ ∃trs ∈ [¯t, ¯t] such that ¯h πj i rs(ers(trs)) > 0 ∀(r, s) ∈ ϵ(πj i ). Since the interval [¯t, ¯t] only contains ¯t, then trs = ¯t ∀(r, s) ∈ ϵ(πj i ). Hence ρ ¯ϕ πj i rs (x, 0) > 0 ⇒ ¯h πj i rs(ers(¯t)) > 0 ⇒ ers(¯t) ∈ (8b) ¯B πj i rs ∀(r, s) ∈ ϵ(πj i ). From (4) and (11) we have eij(¯t) = (4) P (r,s)∈ϵ(πj i ) ers(¯t) ∈ L (r,s)∈ϵ(πj i ) ¯B πj i rs ⊆ (11) Bij ⇒ eij(¯t) ∈ Bij] ⇒ hij(eij(¯t)) > 0. We thus arrived at the conclusion since ¯t ∈ [a, b] and the robust semantics for the F operator we have ρϕij(x, 0) = maxt∈[a,b](hij(eij(t))) > 0 ⇒ x(t) |= ϕij. We highlight that L (r,s)∈ϵ(πj i ) ¯B πj i rs is an axis-aligned hyper- rectangles according to Prop. 2. Moreover, from Assumption 2, each hij is concave, such that satisfying (11) consists in verifying the 2n convex relations −hij(v) ≤ 0 over the vertices v ∈ P(pπj i , νπj i ), where pπj i = P (r,s)∈ϵ(πj i ) p πj i rs and νπj i = P (r,s)∈ϵ(πj i ) ν πj i rs as per Prop. 2. B. Computing optimal parameters In Lemma 1 we showed that (9), (10) and (11) imply x(t) |= ϕπj i ⇒ x(t) |= ϕij. In Thm. 1, we present a procedure to compute the parameters η πj i rs for each task ¯ϕ πj i rs such that the (9), (10) and (11) are satisfied and the volumes of the super-level set ¯B πj i rs are maximized. Namely, given a single hyper-rectangle ¯B πj i rs , it is possible to maximize its volume Qn k=1 ν πj i rs [k], by minimizing (Qn k=1 ν πj i rs [k])−1, which is a convex function since ν πj i rs [k] > 0 ∀k = 1, . . . n. For convenience, we introduce the set Θπj i := {η πj i rs |∀(r, s) ∈ ϵ(πj i )} which gathers all the parameter along a path πj i applied for the decomposition of a given task ϕij and Θ = S (i,j)∈Eψ\\Ec Θπj i is then the set that of all the parameters applied for the decomposition. We are now ready to present our second result. Theorem 1: Consider a multi-agent system with agents in V and subject to a global task ψ according to (2). Further consider the associated task and communication graphs Gc, Gψ such that Eψ \\ Ec ̸= ∅ and Gc respects Assumption 1. For all (i, j) ∈ Eψ \\ Ec consider the paths πj i in Gc and the corresponding task ϕπj i satisfying the conditions in Lemma 1. Define the following convex optimization problem min η πj i rs ∈Θ X (i,j)∈Eψ\\Ec X (r,s)∈ϵ(πj i ) \u0010 n Y k=1 ν πj i rs [k] \u0011−1 (12a) M (r,s)∈ϵ(πj i ) ¯B πj i rs (η πj i rs ) ⊆ Bij ∀(i, j) ∈ Eψ \\ Ec, (12b) Assuming feasibility of (12) and that there exists x(t) such that x(t) |= ¯ψ with ¯ψ according to (6), then x(t) |= ψ. Proof: Given that a solution to (12) exists, then the satisfaction of the constraints set (12b) implies that condition (11) is satisfied for all (i, j) ∈ Eψ \\ Ec. The conditions from Lemma 1 are then satisfied for all ϕπj i with (i, j) ∈ Eψ \\ Ec. We now analyse the satisfaction of ψ and ¯ψ through the definition of the robust semantics such that ρψ = min{min i∈V {ρϕi}, min(i,j)∈Eψ{ρϕij}} and ρ ¯ ψ = min{min i∈V {ρϕi}, min(i,j)∈Eψ∩Ec{ρϕij} min(i,j)∈Eψ\\Ec{ρϕπj i }}; where we have omitted the dependency from (x, 0). Assuming that x(t) |= ¯ψ, then ρϕij(x, 0) > 0 ∀(i, j) ∈ Eψ ∩ Ec and ρϕi(x, 0) > 0. Furthermore, we know from Lemma 1 that ρϕπj i (x, 0) > 0 ⇒ ρϕij(x, 0) > 0 ∀(i, j) ∈ Eψ \\ Ec and eventually ρϕij(x, 0) > 0 ∀(i, j) ∈ Eψ ⇒ x(t) |= ¯ψ ⇒ x(t) |= ψ. If we define the set of edges involved in the decomposition of ψ as Q := S (i,j)∈Eψ\\Ec ϵ(πj i ) then we can write G ¯ ψ as a function of Gψ as G ¯ ψ = add \u0000del(Gψ, Eψ \\ Ec), Q \u0001 , which correspond to deleting all the edges in Gψ not corresponding to an edge in Gc, while we add all the edges from Gc that are introduced by the paths πj i during the decomposition. We have thus deduced a procedure that solves Problem 1. Remark 1: Problem (12) handles cases in which ϕij has conjunctions. Indeed, if ϕij = ∧p k=1ϕk ij for some p ≥ 1 then we define a task (ϕπj i )k as per Lemma 1 and a constraint as per (12b) for each k = 1, . . . p to be introduced in (12). Remark 2: In principle, any type of zonotope can be employed for the decomposition approach developed. How- ever, we remark that the cost of imposing constraint (12b) increases with the number of vertices defining the Minkowski sum in the left-hand side of (12b). We outline that although (12) might yield a solution, there is no guarantee that the tasks ϕπj i computed from (12) in Thm. 1 can be satisfied in conjunction with each other or that they can be satisfied in conjunction with the un-decomposed formulas ϕij ∀(i, j) ∈ Eψ ∩ Ec. In other words, the new task ¯ψ obtained from the optimization problem presented in Thm. 1 is not guaranteed to be satisfiable. We analyse this problem in the next section. V. DEALING WITH CONFLICTS A. Conflicting conjuncitons We consider the following notion of conflicting conjunc- tion for formulas defined by the STL fragment (2): Definition 2: (Conflicting conjunction) A conjunction of formulas V k ϕk ij, where ϕk ij is according to (2b), is a con- flicting conjunction if there does not exist a state trajectory x(t) for the multi-agent system such that x(t) |= V k ϕk ij. In this section, we first state the four types of conflicting conjunctions that we consider for fragment in (2) and we conjecture that these are the only 4 possible types. Second, we provide sufficient conditions that can be enforced as convex constraints in Theorem 1 such that the obtained ¯ψ does not suffer from conflicting conjunctions. We assume that for the original global task ψ, none of these conflicts arise, while they could arise due to the introduction of the new formulas ϕπj i during the decomposition process outlined in Thm. 1. For ease of notation, in this section, we drop the notation ¯ϕ πj i rs and we rewrite all the tasks ϕij in G ¯ ψ for a single edge (i, j) ∈ E ¯ ψ as ϕij = ^ k∈Ig ij ϕk ij ∧ ^ k∈If ij ϕk ij (13a) ϕk ij = G[ak,bk]µk ij if k ∈ Ig ij, (13b) ϕk ij = F[ak,bk]µk ij if k ∈ If ij. (13c) such that Iij := Ig ij∪If ij. Differently from (2b), we highlight that after the decomposition each edge (i, j) ∈ E ¯ ψ can contain parametric tasks according to (9) and un-decomposed tasks from ψ as per (2b) that are directly inherited by ¯ψ. In order to differentiate between the formers and the latters, we introduce the sets ¯F and F such that ϕk ij ∈ ¯F if ϕk ij is a task according to (9), while ϕk ij ∈ F if ϕk ij is defined according to (2b). For any task ϕk ij in (13b)- (13c) we define the associated predicate function hk ij(eij), predicate µk ij(eij) := \b ⊤ if hk ij(eij,ηij)≥0 ⊥ if hk ij(eij,ηij)<0, and super-level set Bk ij = {eij|hk ij(eij) ≥ 0}, which is a parametric hyper- rectangle if ϕk ij ∈ ¯F as per (8b). We now present the four types of conflicting conjunctions we consider. Fact 1: (Conflict of type 1) Consider two tasks ϕk ij and ϕq ij defined over the edge (i, j) ∈ E ¯ ψ and such that k, q ∈ Ig ij If [aq, bq] ∩ [ak, bk] ̸= ∅ and Bk ij ∩ Bq ij = ∅ then ϕk ij ∧ ϕq ij is a conflicting conjunction. Proof: We prove the fact by contradiction. Suppose there exists x(t) such that x(t) |= ϕq ij ∧ ϕk ij. Then ρϕq ij∧ϕk ij(x, 0) = min{ρϕq ij(x, 0), ρϕk ij(x, 0)} > 0 ⇒ ρϕq ij(x, 0) > 0 ∧ ρϕk ij(x, 0) > 0. Recalling the definition of robust semantics for the G operator we have hq ij(eij(t)) > 0 ∀t ∈ [aq, bq] ⇒ eij(t) ∈ Bq ij ∀t ∈ [aq, bq] and hk ij(eij(t)) > 0 ∀t ∈ [ak, bk] ⇒ eij(t) ∈ Bk ij ∀t ∈ [ak, bk]. Since [ak, bk] ∩ [aq, bq] ̸= ∅ then there exists ¯t ∈ [ak, bk] ∩ [aq, bq] for which eij(¯t) ∈ Bk ij∧eij(¯t) ∈ Bq ij. We thus arrived at a contradiction since Bk ij ∩ Bq ij = ∅. Fact 2: (Conflict of type 2) Consider two tasks ϕk ij and ϕq ij defined over the edge (i, j) ∈ E ¯ ψ and such that k ∈ Ig ij, q ∈ If ij. If [aq, bq] ⊆ [ak, bk] and Bq ij ∩Bk ij = ∅ then ϕk ij ∧ϕq ij is a conflicting conjunction. Proof: We prove the fact by contradiction. Suppose there exists x(t) such that x(t) |= ϕq ij ∧ ϕk ij. Then ρϕq ij∧ϕk ij(x, 0) = min{ρϕq ij(x, 0), ρϕk ij(x, 0)} > 0 ⇒ ρϕq ij(x, 0) > 0 ∧ ρϕk ij(x, 0) > 0. Recalling the definition of robust semantics for the F and G operators we have hq ij(eij(t)) > 0 ∀t ∈ [aq, bq] ⇒ eij(t) ∈ Bq ij ∀t ∈ [aq, bq] and there exist ¯t ∈ [ak, bk] such that hk ij(eij(¯t)) > 0 ⇒ eij(¯t) ∈ Bk ij. Since [ak, bk] ⊂ [aq, bq] then ¯t ∈ [aq, bq] and eij(¯t) ∈ Bk ij ∧ eij(¯t) ∈ Bq ij. We thus arrived at the contradiction as Bk ij ∩ Bq ij = ∅. The next two facts define conflicting conjunctions over cycles of tasks in G ¯ ψ. Indeed, conflicts may arise if the cycle closure relation (4) can not be satisfied under a cycle of tasks in G ¯ ψ. Namely, we deal with conjunction of tasks ∧(r,s)∈ϵ(ω)ϕrs where ω is a cycle of length l in G ¯ ψ and ϕrs is a task of type (13b) or (13c). The case in which each ϕrs is a task of type (13a) that contains conjunctions, is a generalization of this simpler case as we show later. For clarity of presentation, we adopt the notation ϕω[k,k+1] to indicate a task ϕrs such that (r, s) = (ω[k], ω[k+1]) for k ∈ 1, . . . l−1. Likewise, we denote the corresponding time interval, the super-level set, predicate function and predicate of ϕω[k,k+1] as [a, b]ω[k,k+1], Bω[k,k+1], hω[k,k+1] and µω[k,k+1] respectively. We thus have the notational equivalence ∧(r,s)∈ϵ(ω)ϕrs = ∧l−1 k=1ϕω[k,k+1]. We now present the next two types of conflicting conjunc- tions. Fact 3: (Conflict of type 3) Consider a cycle ω of length l in G ¯ ψ such that each edge (ω[k], ω[k + 1]) cor- responds to a unique task ϕω[k,k+1] = G[a,b]µω[k,k+1]. If Tl−1 k=1[a, b]ω[k,k+1] ̸= ∅ and p M k=1 Bω[k,k+1] ∩ \u0010 − l−1 M k=p+1 Bω[k,k+1] \u0011 = ∅ (14) for some 1 ≤ p ≤ l − 1 then Vl−1 k=1 ϕω[k,k+1] is a conflicting conjunction. Proof: We prove the theorem by contradiction. As- sume that there exists a state trajectory x(t) such that x(t) |= Vl−1 k=1 ϕω[k,k+1]. Then we know from the robust satisfaction of such conjunction that ρ Vl−1 k=1 ϕω[k,k+1](x, 0) = mink=1,...l−1{ρϕω[k,k+1](x, 0)} > 0 ⇒ ρϕω[k,k+1](x, 0) > 0 ∀k = 1, . . . l − 1. Recalling the definition of robust semantics for the always formulas we can then write hω[k,k+1](eω[k,k+1](t)) > 0, ∀t ∈ [a, b]ω[k,k+1], ∀k = 1, . . . l − 1 and thus eω[k,k+1](t) ∈ Bω[k,k+1], ∀t ∈ [a, b]ω[k,k+1], ∀k = 1, . . . l − 1. We now recall from (4) that for a cycle of edges, we have Pl−1 k=1 eω[k,k+1](t) = 0 ⇒ Pp k=1 eω[k,k+1](t) = − Pl−1 k=p+1 eω[k,k+1](t) for any 1 ≤ p ≤ l − 2. Since we know that Sl−1 k=1[a, b]ω[k,k+1] ̸= ∅ then there exist a time instant ¯t ∈ Sl−1 k=1[a, b]ω[k,k+1] such that the three relations Pp k=1 eω[k,k+1](¯t) ∈ Lp k=1 Bω[k,k+1], − Pl−1 k=p+1 eω[k,k+1](¯t) ∈ \u0000− Ll−1 k=p+1 Bω[k,k+1] \u0001 and Pp k=1 eω[k,k+1](¯t) = − Pl−1 k=p+1 eω[k,k+1](¯t) must hold. We thus arrived at a contradiction as the three aforemen- tioned conditions can not hold jointly if Lp k=1 Bω[k,k+1] ∩ \u0010 − Ll−1 k=p+1 Bω[k,k+1] \u0011 = ∅. Since the argument is indepen- dent of the index p chosen, the proof is valid for any chosen 1 ≤ p ≤ l − 2. Fact 4: (Conflict of type 4) Consider a cycle ω of length l in Gψ such that for each edge (ω[k], ω[k + 1]) there corresponds a unique task ϕω[k,k+1], for which we have ϕω[k,k+1] = F[a,b]µω[k,k+1]∀k = 1, . . . q and ϕω[k,k+1] = G[a,b]µω[k,k+1]∀k = q + 1, . . . l − 1 for some 1 ≤ q ≤ l − 1. If Lp k=1 Bω[k,k+1] ∩ \u0010 − Ll−1 k=p+1 Bω[k,k+1] \u0011 ̸= ∅ for some 1 ≤ p ≤ l−1 and if either 1) q = 1, Tl−1 k=q+1[a, b]ω[k,k+1] ̸= ∅, [a, b]ω[1,2] ⊆ Tl−1 k=q+1[a, b]ω[k,k+1] or 2) q ≥ 1, Tl−1 k=q+1[a, b]ω[k,k+1] ̸= ∅, [a, b]ω[k,k+1] = [¯t, ¯t]∀k = 1, . . . q, ¯t ∈ Tl−1 k=q+1[a, b]ω[k,k+1]; then Vl−1 k=1 ϕω[k,k+1] is a conflict- ing conjunction. Proof: The proof is similar to the proof of Fact 3 and it is not reported due to space limitation. B. Resolving conflicting conjunctions During the process of rewriting ψ into ¯ψ, it is relevant to avoid the insurgence of conflicts 1-4. With this aim, we provide the Lemmas 2-5 which define additional convex constraints on the parameters of the parametric tasks in ¯F. We then include such constraints in (12) to avoid conflicts of type 1-4. Lemma 2: Let (i, j) ∈ E ¯ ψ with task ϕij = ϕs ij ∧ϕr ij such that s, r ∈ Ig ij and [ar, br]∩[as, bs] ̸= ∅. Then, enforcing the convex constraints Bs ij ⊆ Br ij if (br − ar) ≥ (bs − as) ∧ ϕr ij, ϕs ij ∈ ¯F (15a) Br ij ⊆ Bs ij if (br − ar) < (bs − as) ∧ ϕr ij, ϕs ij ∈ ¯F (15b) Bs ij ⊆ Br ij if ϕr ij ∈ F, ϕs ij ∈ ¯F (15c) where F and ¯F are the sets of non-parametric and parametric tasks respectively, ensures that ϕs ij ∧ ϕr ij is not a conflicting conjunction of type 1. Proof: Let [ar, br] ∩ [as, bs] ̸= ∅, then (15) contradicts the conditions of conflicting conjunction of type 1 according to Fact 1. Constraints (15a)-(15b) specify that when two parametric formulas could be in conflict according to Fact 1, then we decide to include the super-level set of tasks with shorter time intervals into the ones with longer time intervals. Lemma 3: Let (i, j) ∈ E ¯ ψ with task ϕij = ϕs ij ∧ϕr ij such that s ∈ Ig ij, r ∈ If ij and [ar, br] ⊆ [as, bs]. Then, enforcing the convex constraints Br ij ⊆ Bs ij if ϕs ij ∈ F, ϕr ij ∈ ¯F (16a) Bs ij ⊆ Br ij if ϕs ij ∈ ¯F, ϕr ij ∈ F (16b) Br ij ⊆ Bs ij if ϕs ij ∈ ¯F, ϕr ij ∈ ¯F (16c) where F and ¯F are the sets of non-parametric and parametric tasks respectively, ensure that ϕs ij ∧ ϕr ij is not a conflicting conjunction of type 2. Proof: Let [ar, br] ⊆ [as, bs], then (16) contradicts the conditions of conflicting conjunction of type 2 according to Fact 2. When more than two tasks are considered in conjunction, then Lemma 2-3 can be applied to every possible couple of tasks in the conjunction. Lemma 4: Let ω be a cycle of length l in G ¯ ψ such that for each (ω[k], ω[k + 1]) there corresponds a unique task ϕω[k,k+1] = G[a,b]µω[k,k+1]. If Tl−1 k=1[a, b]ω[k,k+1] ̸= ∅ then imposing the constraints p M k=1 Bω[k,k+1] ⊆ \u0010 − l−1 M k=p+1 Bω[k,k+1] \u0011 (17) for some 1 ≤ p ≤ l − 1, ensures that Vl−1 k=1 ϕω[k,k+1] is not a conflicting conjunction of type 3. Proof: Relation (17) is a special case of the set inclu- sion in (14). Since we considered Tl−1 k=1[a, b]ω[k,k+1] ̸= ∅, then (17) contradicts (14) as per Fact 3. Lemma 5: Let ω be a cycle of length l in Gψ such that for each edge (ω[k], ω[k + 1]) there cor- responds a unique task ϕω[k,k+1]. Arbitrarily assume ϕω[k,k+1] = F[a,b]µω[k,k+1]∀k = 1, . . . q and ϕω[k,k+1] = G[a,b]µω[k,k+1]∀k = q + 1, . . . l − 1 for some 1 ≤ q ≤ l − 1. If either 1) q = 1, Tl−1 k=q+1[a, b]ω[k,k+1] ̸= ∅, [a, b]ω[1,2] ⊆ Tl−1 k=q+1[a, b]ω[k,k+1], or 2) q ≥ 1, Tl−1 k=q+1[a, b]ω[k,k+1] ̸= ∅, [a, b]ω[k,k+1] = [¯t, ¯t]∀k = 1, . . . q, ¯t ∈ Tl−1 k=q+1[a, b]ω[k,k+1]; then imposing (17) ensures that Vl−1 k=1 ϕω[k,k+1] is not a conflicting conjunction of type 4. Proof: The proof is similar to the proof of Lemma 4 and it is not reported due to space limitations. Remark 3: In the statement of Lemmas 4-5 we con- sidered that no edge of a cycle ω contains conjunctions. Nevertheless, in the case ϕω[k,k+1] contains conjunctions as ϕω[k,k+1] = V s∈Ig ω[k,k+1] ϕs ω[k,k+1] ∧ V s∈If ω[k,k+1] ϕs ω[k,k+1] according to (13a), it is possible to define the combination set C = Ql−1 k=1 Iω[k,k+1] where Iω[k,k+1] contains all the tasks indices for edge (ω[k], ω[k + 1]) as per (13a). Then, for each combination of indices c ∈ C we can check if the conjunction ∧l−1 k=1ϕc[k] ω[k,k+1] satisfies the conditions for conflicting conjunctions of type 3-4 and introduce new constraints of type (17) accordingly. Remark 4: The computation of the Minkowski sum in (17) can possibly become a complex computation as not all the tasks defined over a cycle ω are parametric as per (8). Nevertheless, we can under-approximate the sets Bω[k,k+1] such that ϕω[k,k+1] ∈ F by a hyper-rectangle that can be computed offline when ψ is defined. [19]. We conclude this section with the final result of our work. Theorem 2: Let the conditions of Theorem 1 be satisfied. If a solution to the convex optimization problem (12) exists after the inclusion of constraints (15), (16), (17), then the resulting global formula ¯ψ defined as in (9) from Thm. 1 does not contain conflicting conjunctions as per Fact 1-4. Proof: Follows directly from Lemmas 2-5. Thus, Theorem 2 resolves the feasibility issues that were not considered in Theorem 1 so that ¯ψ does not suffer from conflicting conjunctions according to Fact 1-4. VI. SIMULATIONS We showcase our decomposition approach for a forma- tion problem of 8 agents such that V := {1, . . . 8}. For this task, we assume the agents to be governed by single integrator dynamics ˙xi = ui where xi = [xi, yi]T ∈ R2 represents the position of the agents in a 2-dimensional space. We consider a time-varying formation task divided into two parts. First, a star formation needs to be achieved given by the tasks: ϕ85 = G[10,15](||e85 − [−15, 15]T || ≤ 3), ϕ52 = G[10,15](||e25 − [−15, −15]T || ≤ 3), ϕ34 = G[10,15](||e34 − [15, −15]T || ≤ 3), ϕ74 = G[10,15](||e74 − [15, 15]T || ≤ 3), ϕ46 = G[10,15](||e46 − [10, −10]T || ≤ 2), ϕ56 = G[10,15](||e56 − [−10, −10]T || ≤ 2). Second, the team of agents V1 = {6, 7, 8} and V2 = {1, 2, 3} get detached by the initial star formation such that agents 1 and 6 move independently toward the region x > 5, y > 5 and x > 5, y < −5 respectively while team V1 and V2 achieve a triangle formation from t = 25s to t = 28s. This second part of the formation is given by specifications ϕ1 = F[25,28]([−1, 0](x1 − [5, 0]T ) ≤ 0) ∧ ([0, −1](x1 − [0, −5]T ) ≤ 0, ϕ6 = F[25,28]([−1, 0](x6 − [5, 0]T ) ≤ 0) ∧ ([0, −1](x6 − [0, 5]T ) ≤ 0, ϕ32 = G[25,28](||e32 − [16, 0]T || ≤ 2 √ 2), ϕ87 = G[25,28](||e87 − [16, 0]T || ≤ 2 √ 2), ϕ21 = G[25,28](||e21 − [−8, −8]T || ≤ 2 √ 2), ϕ68 = G[25,28](||e68 − [−8, 8]T || ≤ 2 √ 2). The global task ψ is the conjunction of the given tasks. We use the open-source optimization library CasADi which leverages an interior- point method algorithm to solve the convex program in (12) and find ¯ψ. The algorithm converged to an optimal solution in 0.019s running on an Intel-Core i7-1265U × 12 with 32 GB of RAM. In order to satisfy ¯ψ, we apply a fully distributed control barrier function-based controller similar to the approach proposed previously in [4] so that each agent i ∈ V needs only state information of its 1-hop neighbours in Nc(i) to compute its local control ui. The graphs Gψ, Gc and G ¯ ψ for the simulation are given in Fig. 3c. The tasks ϕ25, ϕ32, ϕ34, ϕ74, ϕ85 and ϕ78 are decomposed according to Table I. The agents’ trajectories are simulated from t = 0 to t = 28 and shown in Fig. 3a-3b. VII. CONCLUSIONS We presented a framework STL task decomposition based on the communication graph of multi-agent systems. We showed that the newly defined tasks imply the original ones when a valid decomposition is obtained. We additionally gave a set of Facts describing four possible conflicting 30 30 20 10 0 10 20 30 30 20 10 0 10 20 (a) 30 30 20 10 0 10 25 20 15 10 10 5 0 5 (b) (c) Fig. 3: Trajectory evolution of the agents from time t = 0s to t = 15s (a) and from time t = 15s to t = 28s (b); Short solid arrows represent the direction of movement of the agents; green lozenges represent the starting positions of the agents, while black stars represent the final positions. Communication graph Gc, initial task graph Gψ and final task graph G ¯ ψ (c). Edges (2, 5), (3, 2), (3, 4), (7, 4), (8, 5), and (7, 8) in Gψ are decomposed over the edges of Gc to obtain G ¯ ψ. ϕπ2 5 π2 5 = [5, 1, 2] ϕπ3 2 π3 2 = [2, 1, 3] ¯ϕπ2 5 51 ¯ϕπ2 5 12 ¯ϕπ3 2 21 ¯ϕπ3 2 13 p πj i rs [9.99, -4.34] [24.99, -10.65] [7.99, 7.99] [7.99, -7.99] ν πj i rs [0.47, 0.47] [1.65, 1.62] [0.95, 0.95] [1.25, 1.26] ϕπ3 4 π3 4 = [4, 1, 3] ϕπ7 4 π7 4 = [4, 6, 7] ¯ϕπ3 4 41 ¯ϕπ3 4 13 ¯ϕπ7 4 46 ¯ϕπ7 4 67 p πj i rs [-9.99, -4.35] [24.99, -10.65] [-9.99, 9.99] [25.00, 5.00] ν πj i rs [0.47, 0.47] [1.62, 1.62] [1.89, 1.89] [0.91, 0.91] ϕπ8 5 π8 5 = [5, 6, 8] ϕπ7 8 π7 8 = [8, 6, 7] ¯ϕπ8 5 56 ¯ϕπ8 5 68 ¯ϕπ7 8 67 ¯ϕπ7 8 86 p πj i rs [10.00, 10.00] [-25.00, 5.00] [7.99, -7.99] [7.99, 7.99] ν πj i rs [1.89, 1.89] [0.91, 0.91] [0.950.95] [1.26, 1.26] TABLE I: Decomposed tasks ϕ25, ϕ32, ϕ34, ϕ74, ϕ85 and ϕ78 with respective parameters. conjunctions related to the applied STL fragment. We then provided a set of convex constraints, under which such conflicts can be avoided during the decomposition. In future work, we will investigate task decomposition under time- varying communication topology and more complex param- eterization for task decomposition. REFERENCES [1] D. Sun, J. Chen, S. Mitra, and C. Fan, “Multi-agent motion plan- ning from signal temporal logic specifications,” IEEE Robotics and Automation Letters, vol. 7, no. 2, pp. 3451–3458, 2022. [2] F. S. Barbosa, D. Duberg, P. Jensfelt, and J. Tumova, “Guiding autonomous exploration with signal temporal logic,” IEEE Robotics and Automation Letters, vol. 4, no. 4, pp. 3332–3339, 2019. [3] L. Lindemann and D. V. Dimarogonas, “Control barrier functions for signal temporal logic tasks,” IEEE control systems letters, vol. 3, no. 1, pp. 96–101, 2018. [4] L. Lindemann and D. V. Dimarogonas, “Control barrier functions for multi-agent systems under conflicting local signal temporal logic tasks,” IEEE Control Systems Letters, vol. 3, no. 3, pp. 757–762, 2019. [5] L. Lindemann, C. K. Verginis, and D. V. Dimarogonas, “Prescribed performance control for signal temporal logic specifications,” in 56th IEEE Conference on Decision and Control, pp. 2997–3002, 2017. [6] F. Chen and D. V. Dimarogonas, “Distributed control of coupled leader-follower multi-agent systems under spatiotemporal logic tasks,” in IFAC World Congress, 2023. [7] N. Mehdipour, C.-I. Vasile, and C. Belta, “Arithmetic-geometric mean robustness for control from signal temporal logic specifications,” in 2019 American Control Conference (ACC), pp. 1690–1695. [8] V. Raman, A. Donz´e, M. Maasoumy, R. M. Murray, A. Sangiovanni- Vincentelli, and S. A. Seshia, “Model predictive control with signal temporal logic specifications,” in 53rd IEEE Conference on Decision and Control, pp. 81–87, 2014. [9] Z. Liu, J. Dai, B. Wu, and H. Lin, “Communication-aware motion planning for multi-agent systems from signal temporal logic specifica- tions,” in 2017 American Control Conference (ACC), pp. 2516–2521. [10] G. A. Cardona, D. Kamale, and C.-I. Vasile, “Mixed integer linear programming approach for control synthesis with weighted signal tem- poral logic,” in Proceedings of the 26th ACM International Conference on Hybrid Systems: Computation and Control, pp. 1–12, 2023. [11] M. Charitidou and D. V. Dimarogonas, “Signal temporal logic task de- composition via convex optimization,” IEEE Control Systems Letters, vol. 6, pp. 1238–1243, 2021. [12] K. Leahy, A. Jones, and C.-I. Vasile, “Fast decomposition of temporal logic specifications for heterogeneous teams,” IEEE Robotics and Automation Letters, vol. 7, no. 2, pp. 2297–2304, 2022. [13] K. Leahy, M. Mann, and C.-I. Vasile, “Rewrite-based decomposition of signal temporal logic specifications,” in NASA Formal Methods Symposium, pp. 224–240, Springer, 2023. [14] O. Maler and D. Nickovic, “Monitoring temporal properties of con- tinuous signals,” in International Symposium on Formal Techniques in Real-Time and Fault-Tolerant Systems, pp. 152–166, Springer, 2004. [15] S. Sadraddini and C. Belta, “Robust temporal logic model predictive control,” in 53rd Annual Allerton Conference on Communication, Control, and Computing, pp. 772–779, IEEE, 2015. [16] S. S. Farahani, V. Raman, and R. M. Murray, “Robust model predictive control for signal temporal logic synthesis,” IFAC, vol. 48, no. 27, pp. 323–328, 2015. [17] V. Raman, A. Donz´e, D. Sadigh, R. M. Murray, and S. A. Seshia, “Reactive synthesis from signal temporal logic specifications,” in Proceedings of the 18th international conference on hybrid systems: Computation and control, pp. 239–248, 2015. [18] S. M. LaValle, Planning algorithms. Cambridge university press, 2006. [19] G. M. Ziegler, Lectures on polytopes, vol. 152. Springer Science & Business Media, 2012. [20] S. Froitzheim, Efficient conversion of geometric state set representa- tions for hybrid systems. PhD thesis, Bachelor’s thesis. RWTH Aachen University, 2016. "
}